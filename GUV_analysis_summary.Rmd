---
title: "GUV_Analysis_summary"
output: html_document
date: "`r Sys.Date()`"
author: "James Foster"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
editor_options: 
  markdown: 
    wrap: sentence
---

## Details

> **AUTHOR**
>
> James Foster 2025 06 05

> **MODIFIED**
>
> James Foster 2025 06 05

> **DESCRIPTION**
>
> Loads the reorganised data from `colour_dance_reorg.csv`, saved from `GUV_organisedata.R`, and generates plots to show the how dances changed as a function of light stimulus.

> **INPUTS**
>
> *`colour_dance_reorg.csv`* `Edrich1979_brightness-accuracy.csv`

> **OUTPUTS**
>
> Plotted results.

> **CHANGES**
>
> -   

> **REFERENCES**
>
> Edrich, W., Neumeyer, C. and von Helversen, O. (1979). “Anti-sun orientation” of bees with regard to a field of ultraviolet light. *J. Comp. Physiol.* 134, 151–157.
>
> Rossel, S. and Wehner, R. (1984). Celestial orientation in bees: the use of spectral cues. *J. Comp. Physiol. A* 155, 605–613.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting up

First load the functions and packages required for this project. These can all be found in `GUV_functions.R`, within the same Github repository.

```{r Load functions and packages}
source('GUV_functions.R')
```

Then load the data that will be used. This includes our own dance data, reorganised by `GUV_organisedata.R` as `colour_dance_reorg.csv`, as well as data from Edrich *et al.* (1979) on the relationship between accuracy (mean vector length), wavelength and intensity. This was manually extracted from Fig. 2 and saved in `"Edrich1979_brightness-accuracy.csv`.

```{r Load data}
#Dance angle data
cd = read.table(file = '1Data/colour_dance_reorg.csv', 
                header = T, 
                sep  = ',')
#Accuracy data
ed = read.table(file = '1Data/Edrich1979_brightness-accuracy.csv', 
                header = T, 
                sep  = ',')
#Inspect each dataset
print(cd)
print(ed)
```

## Format data

Ensure that each variable has the correct data format for subsequent analysis.

```{r Data formatting}
cd = within(cd,
            {
              ID = as.factor(ID) # beedance identifier as a factor
              date = as.factor(date) # date as a factor
              signed_angle = Mod360.180(bearing)  # bearing between -180 and 180
              angle = circular(rad(signed_angle),# bearing between -pi and pi
                               rotation = 'clock') # circular format suppresses later warnings
            }
)
u_id = with(cd, unique(ID)) # unique beedances
length(u_id)#169 beedances
```

Identify dances in which all four stimulus conditions were used.

```{r full condition}
luc = sapply(u_id,
              FUN = IndCond,
              dt = cd)

#Most individuals that made it to bright green 
full_ids = u_id[luc == 4]
length(full_ids)#19 individuals
#extract just those individuals

#find data for full condition individuals
full_cd = subset(cd, ID %in% full_ids)
```

## Plot the raw dance data

Plot all 169 dances

```{r Raw dances, echo=FALSE, warning=FALSE}

#set up a sequence for the axes
xc = seq(from = -pi, to = pi-1e-16, length.out = 1e3)
par(mfrow = c(2, 2),
    mar = c(0,0,0,0))
par(pty = 's')

#add legend to 1st page
plot(x = NULL,
     xlim = c(-1,1),
     ylim = c(-1,1),
     pch = 19,
     axes = FALSE,
     xlab = '',
     ylab = '',
     main = ''
)
legend(x = 'center',
       legend = c('Green Bright',
                  'Green Dim',
                  'UV Bright',
                  'UV Dim',
                  'Sun azimuth (North = Up)'),
       col = c('green',
               'darkgreen',
               'magenta',
               'purple',
               'orange'),
       pch = c(21,21,21,21,NA),
       lty = c(NA, NA, NA, NA, 1),
       lwd = c(2,2,2,2,3)
       )
#loop through individuals
for(ii in u_id)
{
  mnv_gh = Mvec(subset(cd, ID %in% ii & colour %in% 'g' & brightn %in% 'h')$angle)
  mnv_gl = Mvec(subset(cd, ID %in% ii & colour %in% 'g' & brightn %in% 'l')$angle)
  mnv_uh = Mvec(subset(cd, ID %in% ii & colour %in% 'u' & brightn %in% 'h')$angle)
  mnv_ul = Mvec(subset(cd, ID %in% ii & colour %in% 'u' & brightn %in% 'l')$angle)
  plot(x = NULL,
       xlim = 100*c(-1,1),
       ylim = 100*c(-1,1),
       pch = 19,
       axes = FALSE,
       xlab = '',
       ylab = '',
       main = ''
       )
  abline(a = 0, b = 1, col = 'gray90')
  abline(a = 0, b = -1, col = 'gray90')
  abline(h = 0, v = 0, col = 'gray75')
  lines(x = 20*sin(xc), y = 20*cos(xc), lty = 3)
  lines(x = 40*sin(xc), y = 40*cos(xc), lty = 3)
  lines(x = 60*sin(xc), y = 60*cos(xc), lty = 3)
  lines(x = 80*sin(xc), y = 80*cos(xc), lty = 3)
  text(x = 1:4*20,
       y = c(0,0,0,0),
       labels = paste(' run', 1:4*20), 
       cex = 0.3,
       adj = c(0,1))
  with(subset(cd, ID %in% ii),
       {
  lines(x = c(0, 100*sin(sun_az_rad)),
        y = c(0, 100*cos(sun_az_rad)),
        col = adjustcolor('orange',alpha.f = 0.5),
        lwd = 2)
  points(x = run*sin(as.numeric(angle)),
         y = run*cos(as.numeric(angle)),
         bg = gray(level = 1.0,
                   alpha =  0.4),
         col = c('green', 'darkgreen', 'magenta', 'purple')
                [ifelse(colour %in% 'g',
                        yes = ifelse(brightn %in% 'h', yes = 1, no = 2),
                        no = ifelse(brightn %in% 'h', yes = 3, no = 4))],
        pch = 21,
        lwd = 2
       )
       }
  )
  lines(x = c(0,100*sin(mnv_gh['mu'])*mnv_gh['rho']), 
        y = c(0,100*cos(mnv_gh['mu'])*mnv_gh['rho']), 
        col = 'green', 
        lwd = 1)
  lines(x = c(0,100*sin(mnv_gl['mu'])*mnv_gl['rho']), 
        y = c(0,100*cos(mnv_gl['mu'])*mnv_gl['rho']), 
        col = 'darkgreen', 
        lwd = 1)
  lines(x = c(0,100*sin(mnv_uh['mu'])*mnv_uh['rho']), 
        y = c(0,100*cos(mnv_uh['mu'])*mnv_uh['rho']), 
        col = 'magenta', 
        lwd = 1)
  lines(x = c(0,100*sin(mnv_ul['mu'])*mnv_ul['rho']), 
        y = c(0,100*cos(mnv_ul['mu'])*mnv_ul['rho']), 
        col = 'purple', 
        lwd = 1)
  mtext(ii,side = 3,line = -2)
}
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## Accuracy effects

Calculate the mean vectors for each set of waggle-runs under each lighting condition.

```{r Summarise, echo=FALSE}
#calculate mean vectors
mean_vectors = aggregate(angle~ID*brightn*colour+sun_az, # N.B. Including sun azimuth drops some cases without a time stamp
                         data = cd,
                         FUN = rho.circular
)
#correct names
mean_vectors = within(mean_vectors,
                      {mean_vector = angle; rm(angle)} # anlge now indicates a mean vector, not an angle
)
#add kappa
mle_estimates = aggregate(angle~ID*brightn*colour+sun_az,
                          data = cd,
                          FUN = MLE_est
)
#add to the summary table and 
#calculate inverse softplus kappa
mean_vectors = within(mean_vectors,
                      {
                        mu = deg(mle_estimates$angle[,'mu'])
                        kappa = mle_estimates$angle[,'kappa']
                        iskappa  = inv_softplus(kappa)
                      }
)
#find the full condition individuals
mean_vectors_full = subset(mean_vectors,
                           subset = ID %in% full_ids)
```

The first thing we notice is that in the low intensity conditions the accuracy is generally lower than for the high intensity conditions.

```{r Plot mean vectors, echo=FALSE}
boxplot(mean_vector~colour*brightn,
        data = mean_vectors,
        ylim = c(0,1),
        col = adjustcolor(c('green2',
                            'purple',
                            'darkgreen',
                            'purple4'), alpha.f = 0.5),
        outline = FALSE)
stripchart(mean_vector~colour*brightn,
           data = mean_vectors,
           add = TRUE,
           vertical = TRUE,
           method = 'jitter',
           col = adjustcolor(c('green2',
                               'purple',
                               'darkgreen',
                               'purple4'), alpha.f = 0.5),
           bg = gray(level = 0,
                     alpha = 0.1),
           pch = 21)
#Identify stimuli
stim = apply(X = expand.grid(c = c('g','u'),b = c('h','l')),
             FUN = paste,
             collapse = '',
             MARGIN = 1)
#Plot lines linking dances by the same individual
invisible(
  {
    lapply(X = u_id,
           FUN = Plt_mvec
           )
  })
abline(h = c(0,1))
```

This effect is even clearer if we look at just the full condition dances.

```{r Plot full condition mean vectors}
# boxplot(mean_vector~colour*brightn,
#         data = mean_vectors_full,
#         ylim = c(0,1),
#         col = adjustcolor(c('green2',
#                             'purple',
#                             'darkgreen',
#                             'purple4'), alpha.f = 0.5),
#         outline = FALSE)
stripchart(mean_vector~colour*brightn,
           data = mean_vectors_full,
           # add = TRUE,
           vertical = TRUE,
           method = 'jitter',
           jitter = 0.02,
           col = adjustcolor(c('green2',
                               'purple',
                               'darkgreen',
                               'purple4'), alpha.f = 0.5),
           bg = gray(level = 0,
                     alpha = 0.1),
           pch = 21)
#Plot lines linking dances by the same individual
invisible(
  {
    lapply(X = full_ids,
           FUN = Plt_mvec
           )
  })
abline(h = c(0,1))
```

### Comparison with Edrich *et al.* (1979)

How does this compare with previous experiments in which a light spot (x°) was presented through bandpass filters and ND filters to produce different intensities? In that data, there was a clear sigmoidal relationship between intensity and accuracy (mean vector length).

```{r Edrich raw data, echo=FALSE}
with(ed,
     {
     plot(x = log10(intensity),
          y = accuracy,
          xlim = c(9,14),
          ylim = c(0,1),
          main = 'Data from Edrich et al. 1979, Fig. 2',
            xlab = 'log10(intensity) (photons/cm2/s)',
            ylab = 'accuracy (r)',
          pch = 21,
          cex = 1.5,
          col = 'black',
          bg = sapply(paste(wavelength),
                       FUN = switch,
                       `354` = 'purple',
                       `429` = 'blue',
                       `535` = 'darkgreen',
                       'red')
          )
     abline(h = c(0,1))
     }
     )

legend(x = 'bottomright',
       legend = paste(sort(unique(ed$wavelength),
                     decreasing = TRUE), 'nm'),
       col = c('darkgreen','blue', 'purple'),
       pch = c(20, 20, 20))
```

This is best modelled with a nonlinear (psychometric model) following the beta distribution (for variables bounded between zero and one).

```{r Fit sigmoid to Edrich data}

#set up model fit
formula_beta = bf(
  formula = accuracy ~ 
    inv_logit(LogitBase) + (1 - inv_logit(LogitLapse) - inv_logit(LogitBase) ) *#curve region
    inv_logit( 4.39*(log10_intensity - Inflex) / exp(LogWidth) ) , #inflection-width curve
  # for each of these parameters, we can set up a separate formula 
  # that describes how to predict them from the data 
  #Base rate of correct choices: "
  LogitBase ~ 1, #Base rate of correct choices: "~ 1" gives the instruction "estimate the mean across all data"
  #Lapse rate on a log(odds) scale:
  LogitLapse ~ colour, #this is similar to the formula in our LMM example
  #inflection point of the initial curve:
  Inflex ~ colour, #N.B. this is similar to the intercept, so it does not include effects of stimulus level
  #log 80% width of the curve:
  LogWidth ~ colour, #N.B. this is similar to the slope, so all of its effects depend on stimulus level
  family = Beta(link = "identity", link_phi = 'log'),
  nl = TRUE)#the joint distribution for these parameters is undefined, and therefore the parameters themselves are "nonlinear"


#set up priors
prior_beta = get_prior(formula = formula_beta,
                     data = ed)
#set the prior distribution
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogitBase' &
                      coef %in% 'Intercept' 
                  ] = 'normal(-1,1)' #a normal distribution centred on plogis(-1) = 0.27
                  })
#this prior is automatically bounded between 0 and 1, 
#Lapse rate priors ---------------------------------------------------
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogitLapse' &
                      coef %in% 'Intercept' 
                  ] = 'normal(-3,2)' #a normal distribution centred on -3
                  })

#for all other fixed effects on lapse rate, we'll suggest values around 0 (no effect)
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogitLapse' &
                      coef %in% 'colourblue' 
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 3
                  })
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogitLapse' &
                      coef %in% 'colourUV' 
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 3
                  })

#Inflection point priors ---------------------------------------------
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'Inflex' &
                      coef %in% 'Intercept'
                  ] = 'normal(11,2)' #a normal distribution:mean 11, sd 2
                  })
#for all coefficients, we'll suggest values around 0 (no effect)
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'Inflex' &
                      coef %in% 'colourblue' 
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 2
                  })

prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'Inflex' &
                      coef %in% 'colourUV' 
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 2
                  })

#Rise region width priors --------------------------------------------
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogWidth' &
                      coef %in% 'Intercept' 
                  ] = 'normal(1,2)' #a normal distribution:mean 1, sd 3
                  })
#for all coefficients, we'll suggest values around 0 (no effect)
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogWidth' &
                      coef %in% 'colourblue'
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 3
                  })
prior_beta = within(prior_beta, 
                  { prior[
                    class %in% 'b' & #just the fixed effects
                      nlpar %in% 'LogWidth' &
                      coef %in% 'colourUV'
                  ] = 'normal(0,2)' #a normal distribution:mean 0, sd 3
                  })


system.time(
  {
    beta_fit = brm( formula = formula_beta, # using our nonlinear formula
                     data = ed, # our data
                     prior = prior_beta, # our priors 
                     iter = 4000, # long run for 2000 iterations
                     chains = 4, # 4 chains in parallel
                     cores = 4, # on 4 CPUs
                     refresh = 0, # don't echo chain progress
                     control = list(adapt_delta = 0.95), #finer sampling
                     backend = 'cmdstanr') # use cmdstanr (other compilers broken)
  }
)
```
