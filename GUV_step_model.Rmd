---
title: "GUV_step_model"
author: "James Foster"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    fig_caption: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Details

**DESCRIPTION**

A step-by-step approach to building an appropriate model for bimodality in dance data for the 'UV dim' stimulus.

**INPUTS**

`GUV_functions.R`

**OUTPUTS**

Models and plotted estimates.

**REFERENCES**

**Experimental approach**

Edrich W, Neumeyer C & von Helversen, O.
(1979) “Anti-sun orientation” of bees with regard to a field of ultraviolet light.
*J. Comp. Physiol.* 134, 151–157.

Rossel, S.
& Wehner, R.
(1984).
Celestial orientation in bees: the use of spectral cues.
*J. Comp. Physiol. A* 155, 605–613.

**modelling methods**

Sayin S, Couzin-Fuchs E, Petelski I, Günzel Y, Salahshour M, Lee CY, Graving JM, Li L, Deussen O, Sword GA, et al. (2025) The behavioral mechanisms governing collective motion in swarming locusts.
*Science* 387(6737):995–791

Gabry J, Češnovar R, Johnson A (2022).
cmdstanr: R Interface to 'CmdStan'.
<https://mc-stan.org/cmdstanr/>

Bürkner, P.-C.
(2018).
Advanced Bayesian Multilevel Modeling with the R Package brms.
*The R Journal* 10, 395–411.

Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P. and Riddell, A.
(2017).
Stan: A Probabilistic Programming Language.
*Journal of Statistical Software* 76 doi: 10.18637/jss.v076.i01

Vehtari, A., Gelman, A., and Gabry, J.
(2017) Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.
*Statistics and Computing* 27(5), 1413–1432.
<doi:10.1007/s11222-016-9696-4>.

Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A.
(2021).
Implicitly adaptive importance sampling.
*Statistics and Computing* 31, 16.
<doi:10.1007/s11222-020-09982-2>.

# Motivation

## Identifiability

During estimation, the two modes of a bimodal model may be indistinguishable, and even interchangeable, which produces problems with identifiability.
Parameter estimation relies on stability of estimates, which can be undermined if an estimate for one parameter 'switches places' with an estimate for another, as can occur when different chains or iterations identify opposite modes as the 'primary mode'.
The shape of the probability density function for a bimodal distribution also depends on the combination of concentration ($\kappa$) and proportion (in `brms` $\theta$) at each mode.
This introduces an additional challenge for identifiability, since low probability of observations near a mode may result from that mode having low concentration or a small proportion of the data, or both.

## Bimodality of differences and dances

In this dataset, dances during the 'UV dim' condition are typically separated from those under the 'UV bright' condition by $\pm90°$.
For most dances a single primary mode can be found can be found to the left or right of the mean for the 'UV bright' condition, with approximately equal frequency.
For some dances, two modes occur to both the right and left of the 'UV bright' mode, with varying proportions of the data around either.

## Reducing uncertainty

Taken in isolation, the data for the 'UV dim' condition have relatively low concentration, and vary greatly in orientation as a function of sun azimuth (known) and advertised location (not known).
The direction of the advertised location can be estimated from the 'UV bright' condition, for which concentration was high, so this information can be used to reduce uncertainty about advertised direction.
Since dances by the same individual should generally have similar properties, a reasonable assumption would be that the concentration parameter $\kappa$ should be similar between the mode of the 'UV bright' dance and the 'UV dim' dance, after accounting for any population-level effect of decreased brightness.
Since leftwards and rightwards turns appear interchangeable (at least equally likely) it is also possible that the two modes for our bimodal turns, and bimodal dances, should have similar concentration.

## Step-by-step strategy

Ideally, the parameters associated with each of these assumptions would be estimated simultaneously within the same model.
Due to the aforementioned identifiability issues, it is preferable to first establish the plausible properties of each parameter under stricter assumptions, before attempting models with greater complexity.
Here, we will begin by establishing a model for just the 'UV bright' condition, and then a model for the change between the 'UV bright' and 'UV dim' conditions, starting with strong assumptions about the stability of $\kappa$ and $\theta$ across individuals and conditions, to determine a set of reasonable assumptions under which to identify the population-level bimodal effects of the change between bright and dim UV light.

# Set up workspace

Estimating these models, we need to load the appropriate functions.
Make sure that the `circular`, `cmdstanr` and `brms` are installed, and 
(on Windows) that you have installed the latest version of [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

```{r Load functions and packages}
source('GUV_functions.R')
```

Set up some colours for plotting.

```{r Set up plot colours}
col_kappa = '#1E78B5'#colour for kappa parameter
col_rho = '#F08024' #colour for mean vector length
col_sd = '#E74A29' #colour for SD and mean angle
col_sd2 = '#E57461' #colour for other SD heuristics
col_pdf = adjustcolor(col = '#21A885', # colour for probability density
                      alpha.f = 0.7)
col_obs = '#3E1F51' #colour for control observations
col_treat = '#006400' # colour for treatment observations
```

# Prepare data

Then load the data that will be used.
This is our dance data, reorganised by `GUV_organisedata.R` as `colour_dance_reorg.csv`.

```{r Load data}
#Dance angle data
cd = read.table(file = '1Data/colour_dance_reorg.csv', 
                header = T, 
                sep  = ',')
head(cd)
```

## Format data

Ensure that each variable has the correct data format for subsequent analysis.

```{r Data formatting}
cd = within(cd,
            {
              ID = as.factor(ID) # beedance identifier as a factor
              date = as.factor(date) # date as a factor
              signed_angle = Mod360.180(bearing)  # bearing between -180 and 180
              angle = circular(rad(signed_angle),# bearing between -pi and pi
                               rotation = 'clock') # circular format suppresses later warnings
            }
)
u_id = with(cd, unique(ID)) # unique beedances
length(u_id)#169 beedances
```
```{r Shorten variable names for modelling}
cd = within(cd,
            {
              BR = brightn
              CL = colour
              DT = date
              RN = run
            }
)
```

## Identify dances for both conditions
Identify dances in which all four stimulus conditions were used.

```{r both conditions}
uvc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              colour %in% 'u'),
                     {
                       length(unique(brightn))
                       }
                     )
              },
              dt = cd)

#There should be two brightness levels for UV
uv_ids = u_id[uvc == 2]
length(uv_ids)#most individuals
#extract just those individuals

#find data for full condition individuals
cd_uv = subset(cd, ID %in% uv_ids)
```

# Set up circular modelling

```{r Set up the circular model custom family}
#set up required Stan functions
#circular modulo in Stan code
modulo_circular_fun = stanvar(scode = "
  real modulo_circular(real y) {
    return fmod(y + pi(), 2*pi()) - pi();
  }
",
                           block = 'functions')

#custom likelihood function using the shifted modulo link
#additional function to account for vectors
stan_unwrap_fun = stanvar(scode = "
    real unwrap_von_mises_lpdf(real y, real mu, real kappa) {
      return von_mises_lpdf(y | modulo_circular(mu), kappa);
    }
    real unwrap_von_mises_rng(real mu, real kappa) {
      return von_mises_rng( modulo_circular(mu) , kappa);
    }
    real unwrap_von_mises_vect_lpdf(vector y, real mu, real kappa) {
    real tmp = 0;
    for(i in 1:size(y))
    {
    tmp = tmp + unwrap_von_mises_lpdf(y[i] | mu, kappa);
    }
      return tmp;
    }
  ",
                          block = 'functions')


#Introduce stan variable for kappamu
stan_softkappamu = stanvar(scode = "
real softkappamu;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mu = log1p_exp(softkappamu);
          ", 
          block = 'genquant')

#define the custom family
unwrap_von_mises = custom_family(
  name = "unwrap_von_mises",
  dpars = c("mu",
            "kappa"),
  links = c('identity',#N.B. the link function is defined via the LPD function
            "softplus"), 
  lb = c(-pi,#lower bound of mu should be -pi
         0),
  ub = c(pi,#upper bound of mu should be pi
         NA),
  type = "real",#takes continuous response data
)

```


```{r Set up plotting functions for circular estimates}

#add contours
Draws2Cont = function(draws,
                      palette = 'Heat 2',
                      nlevels = 20,
                      x_string = 'sin(Intercept)*A1(softplus(Intercept_kappa))',
                      y_string = 'cos(Intercept)*A1(softplus(Intercept_kappa))',
                      alpha = 200/255,
                      ngrid = 25, # defaults to a 25x25 grid
                      cropc = FALSE, #crop region outside circle
                      denstype = 'relative' # 'normalised' or 'relative' (normalised fails to plot low densities)
)
{
  kdc = with(draws,
             {
               MASS::kde2d(x = eval(str2lang(x_string)),
                           y = eval(str2lang(y_string)),
                           n = ngrid)
             }
  )
  if(cropc)
  {
    xy = with(kdc, expand.grid(x = x,y= y))#find coordinates of z variable
    idc = with(xy, x^2+y^2 < 1.0)
    #crop edge of circle
    kdc = within(kdc,
                 {z[!idc] = 0})
  }
  with(kdc,
       {
         .filled.contour(x = x,
                         y = y,
                         z = z,
                         levels = (1:nlevels)*
                           switch(EXPR = denstype,
                                  relative = max(z/nlevels),
                                  normalised = sum(z/nlevels),#warning, fails to plot low densities
                                  max(z/nlevels)
                           ),
                         col = hcl.colors(n = nlevels,
                                          palette = palette,
                                          rev = TRUE,
                                          alpha = alpha)
         )
       }
  )
}
```

# Model for UV Bright

Find data for the 'UV bright' condition.
```{r UV bright subset}
cd_uvh = subset(cd,
               colour %in% 'u' &
                 brightn %in% 'h')
id_uvh = with(cd_uvh, unique(ID))
length(id_uvh)#nearly all
```


## Set up formula and priors

In this model each individual dance may have a different preferred direction $\mu_i$
 relative to the population mean direction $\mu_0$. This is written explicitly as
 a nonlinear formula $\mu \sim \mu_0 + \mu_i$. Individuals may also differ in 
concentration, which is implied by the linear formula $\kappa \sim 1 + (1|ID)$.
```{r UV bright formula}

formula_uvh = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui), 
  mu0 ~ 1, # all conditions
  mui ~ 0 + ID, # mean angle combines fixed and random effects
  kappa ~  1 + (1 |ID), #for kappa this occurs in linear space, and BRMS can set it up automatically
  family = unwrap_von_mises,#mod mu, kappa via the softplus
  nl = TRUE)#to accept user-defined extra parameters (zmu) we need to treat the formula as nonlinear

```

This model requires priors that indicate the likely values of $\mu_0$ and $\kappa_0$,
as well as the likely relationships between $\kappa_i$ and implied hyperparameter $\sigma_\kappa$,
and defining a role for the hyperparameter $\kappa_\mu$, which was introduced 
in the Stan code above (in inverse-softplus space: $\kappa_\mu = \log(1 + \exp(\text{softkappamu})$).

```{r UV bright priors}

#priors for mu
pr_mu_uvh = prior('normal(0,3*pi()/2)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior(paste("target +=", 
                            'normal_lpdf(b_mui | 0, 2*pi())'# additional prior to keep estimates from walking around the circle
            ),
            check = FALSE) +
                  set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                            check = FALSE)

#priors for kappa
pr_kappa_uvh = 
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', dpar = 'kappa')
  
#all unimodal priors
pr_uvh = pr_mu_uvh + pr_kappa_uvh
```

## Run the model for UV bright
```{r UV bright model}

#very long compile time
system.time(
  {
    
    model_uvh = brm(formula = formula_uvh,
                   data = cd_uvh,
                   prior = pr_uvh,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 2000, # longer warmup to efficiently sample all parameters
                   iter = 4000, # longer warmup to efficiently sample all parameters
                   control = list(adapt_delta = 0.80),
                   silent = 2, # echo only high priority Stan messages
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/UV_high_model.RData',
     model_uvh)#save for future reference

```

This model identifies both a population level bias (near 0°) and individual biases
 with stable parameter estimates on the 'unwrapped' (circular modulo) scale.
 
```{r Inspect UV bright model}
load(file = '2Results/UV_high_model.RData')
#population kappa and its standard deviation
plot(model_uvh,
      ask = FALSE,
      variable = c('Intercept_kappa', 'sd', 'kappa_mu'),
      regex = TRUE) #plot raw estimates
#population directional bias
plot(model_uvh,
      ask = FALSE,
      variable = 'mu0',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates

```

The population level mean angle $\mu_0$ appears to oscillate gradually over the course of sampling


```{r Inspect individual means UV bright model}
#inidividual but they overlap when unwrapped
plot(x = model_uvh,
     variable = 'mui',
     regex = TRUE,
     ask = FALSE,
     transform = unwrap_circular_deg) #plot transformed estimates
```

Calculating the $\hat{R}$ values for unwrapped estimates for $\mu_i$ reveals that 
all estimates converged well ( $\hat{R}<1.01$).

```{r Convergence heuristics for the UV bright model}

sm_uvh = summary(model_uvh,
                 variable = c('Intercept_kappa', 'sd', 'kappa_mu'),
                regex = TRUE)
print(sm_uvh, digits = 2)
#mu0 and mui look bad, but good after unwrapping
UnwrapRhats(model_uvh,
            variable = '^b_mu0')
summary(UnwrapRhats(model_uvh,
            variable = '^b_mui') )
```

The estimates of $\kappa_\mu$ here have a slight positive bias, due to a combination of low sample size and our prior to higher values.
The model nonetheless recovers good estimates of $\mu_0$ and $\mu_i$.
Importantly, this also allows us to estimate population $\kappa$, that is the concentration of the average individual, which needs to be distinguished from individual differences and the concentration across individuals.


## Extract predictions for the UV high model

Since this model's estimates provide context for the 'UV dim' data, most importantly 
the directional bias for each individual dance, we need to extract the estimates 
for each individual before attempting the next model.


```{r Plot the UV bright model}
mu_id_uvh = rep(NA, length(id_uvh))
kappa_id_uvh = rep(NA, length(id_uvh))

draws_uvh = as_draws_df(model_uvh)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uvh) )
{
  mu_name = paste0('b_mui_ID',id_uvh[i])
  kappa_name = paste0('r_ID__kappa[',id_uvh[i],',Intercept]')
  with(subset(cd_uvh, ID %in% id_uvh[i]),
  {
    PCfun(angles = bearing,
         col = col_obs,
         plot_rho = FALSE)
    }
  )
  Draws2Cont(draws_uvh,
             x_string = 'sin(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))'
             )
  mu_id_uvh[i] = with(draws_uvh,
                      {
                        # median.circular(
                        #      circular(x = 
                        #      mod_circular(b_mu0_Intercept + get(mu_name)),
                        #                             units = 'radians',
                        #                             rotation = 'clock',
                        #                             zero = pi/2)
                        #                    )[1]
                        median(
                             unwrap_circular( 
                             b_mu0_Intercept + get(mu_name))
                        )
                      })
  kappa_id_uvh[i] = with(draws_uvh,
                         {softplus(median(Intercept_kappa+get(kappa_name)))} )
  
  arrows.circular(x = circular(x = mu_id_uvh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_uvh[i]),
                 lwd = 2,
                 length = 0.1/1.25,
                 col = adjustcolor(col_sd, alpha.f = 200/255))
}
#Add the population of biases
dev.new()
par(mfrow = c(1,3))
PCfun(angles = deg(mu_id_uvh),
      col = col_rho,
      plot_rho = FALSE)
Draws2Cont(draws = draws_uvh,
           x_string = 'sin(b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept)*
             A1(kappa_mu)'
           )

with(draws_uvh,
     arrows.circular(x = mean.circular(circular(b_mu0_Intercept,
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2)
     )[1],
     y = A1(median(kappa_mu)),
     lwd = 2,
     length = 0.1/1.25,
     col = adjustcolor(col_sd, alpha.f = 200/255))
)


with(draws_uvh,
     VertHist(data = softplus(Intercept_kappa), 
              main = '\npopulation kappa',
              ylim = c(0, 30),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)
with(draws_uvh,
     VertHist(data = kappa_mu, 
              main = '\npopulation kappamu',
              ylim = c(0, 5),
              col = adjustcolor(col_sd, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5)
```


# Model for bimodal change

## Prepare data

Subtract estimated mean for 'UV bright' dances from dance angles for 'UV dim'.

```{r Calculate change data}
cd_change = within(cd_uv,
                   {
                   change_angle = mapply(FUN = function(id, ang)
                                   {
                                   ii = which(id_uvh %in% id)
                                   return( mod_circular(ang - mu_id_uvh[ii]) )
                                 },
                                 id = ID,
                                 ang = angle
                                 )
                   }
)
```

## Inspect data

Somewhat contrary to expectations, many individuals have their primary mean close
 to 0°, that is no change. It is possible that the mean vectors 

```{r Plot the estimated change data}
id_uv = with(cd_uv, unique(ID))
calc_mu = rep(NA, length(id_uv))
par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uv) )
{
  with(subset(cd_change, ID %in% id_uvh[i]),
  {
    PCfun(angles = deg(change_angle),
         col = col_sd2)}
  )
  calc_mu[i] = with(subset(cd_change, ID %in% id_uvh[i]),
                    {mean.circular(x = circular(change_angle, template = 'none'))}
                    )
}
dev.new()
PCfun(angles = deg(calc_mu),
      col = col_rho,
      shrink = 2)
```



## Set up formula and priors

The simplest possible model for a bimodal distribution with individual effects, 
needs to account for individual differences in primary mode and concentration. 
For simplicity, here it is assumed that individual differences affect the primary
 and secondary mode (separated by approximately 180°) identically, and that 
both modes have the same concentration $\kappa_1 = \kappa_2 = \log(1+\exp(k_1))$. 

```{r Change formula}

formula_change = bf(#modulus may not be necessary, included in lpd function
  formula = change_angle ~ mu,
  nlf(mu1 ~ mu0 + mui), #primary mean, population mean plus individual mean
  nlf(mu2 ~ mu0 + mu1 + mui), #secondary mean, population mean plus offset, plus individual mean
  mu0 ~ 1, #primary mean
  mui ~ 0 + ID, # mean angle combines fixed and random effects
  mu1 ~ 1, #angle between primary mean and secondary mean
  nlf(kappa1 ~ k1), #concentration for primary mean
  nlf(kappa2 ~ k1), #concentration for secondary mean
  k1 ~ 1 + (1 |ID), #for kappa this occurs in linear space, and BRMS can set it up automatically
  theta1 ~ 1 + (1 |ID), #for mixture weighting, this is specific to individual and condition combination
  family = mixture(unwrap_von_mises,#primary mean distribution
                   unwrap_von_mises #secondary mean distribution
  ),#mixture, specified by the log ratio of theta1 : theta2
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear
```

This model requires priors additional priors for $\mu_1$ and $\kappa_2$. For a 
near axial bimodal distribution the expectation would be that $\mu_1$ and $\mu_2$
 are separated by ≈180°, so the prior for `mu1` is set to this value. For this 
formula, $\kappa_1$ and $\kappa_2$ are both set deterministically by the parameter
 `k1`, so both can take the same prior.

```{r change priors}

#priors for mu
pr_mu_change = prior('normal(0,3*pi()/2)', class = 'b', nlpar = 'mu0') +
                prior('normal(pi,pi()/2)', class = 'b', nlpar = 'mu1') + #expected offset of ≈180°
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior(paste("target +=", 
                            'normal_lpdf(b_mui | 0, 2*pi())'# additional prior to keep estimates from walking around the circle
            ),
            check = FALSE) +
                  set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                            check = FALSE)

#priors for kappa
pr_kappa_change = 
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa1') +
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa2') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', nlpar = 'k1')

#priors for theta
pr_theta_change = 
                  prior('normal(0,1)', class = 'Intercept', dpar = 'theta1') +
                  prior('student_t(3, 0, 0.5)', class = 'sd', dpar = 'theta1')
  
#all unimodal priors
pr_change = pr_mu_change + pr_kappa_change
```
