---
title: "GUV_step_model"
author: "James Foster"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    fig_caption: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Details

**DESCRIPTION**

A step-by-step approach to building an appropriate model for bimodality in dance data for the 'UV dim' stimulus.

**INPUTS**

`GUV_functions.R`

**OUTPUTS**

Models and plotted estimates.

**REFERENCES**

**Experimental approach**

Edrich W, Neumeyer C & von Helversen, O.
(1979) “Anti-sun orientation” of bees with regard to a field of ultraviolet light.
*J. Comp. Physiol.* 134, 151–157.

Rossel, S.
& Wehner, R.
(1984).
Celestial orientation in bees: the use of spectral cues.
*J. Comp. Physiol. A* 155, 605–613.

**modelling methods**

Sayin S, Couzin-Fuchs E, Petelski I, Günzel Y, Salahshour M, Lee CY, Graving JM, Li L, Deussen O, Sword GA, et al. (2025) The behavioral mechanisms governing collective motion in swarming locusts.
*Science* 387(6737):995–791

Gabry J, Češnovar R, Johnson A (2022).
cmdstanr: R Interface to 'CmdStan'.
<https://mc-stan.org/cmdstanr/>

Bürkner, P.-C.
(2018).
Advanced Bayesian Multilevel Modeling with the R Package brms.
*The R Journal* 10, 395–411.

Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P. and Riddell, A.
(2017).
Stan: A Probabilistic Programming Language.
*Journal of Statistical Software* 76 doi: 10.18637/jss.v076.i01

Vehtari, A., Gelman, A., and Gabry, J.
(2017) Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.
*Statistics and Computing* 27(5), 1413–1432.
<doi:10.1007/s11222-016-9696-4>.

Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A.
(2021).
Implicitly adaptive importance sampling.
*Statistics and Computing* 31, 16.
<doi:10.1007/s11222-020-09982-2>.

# Motivation

## Identifiability

During estimation, the two modes of a bimodal model may be indistinguishable, and even interchangeable, which produces problems with identifiability.
Parameter estimation relies on stability of estimates, which can be undermined if an estimate for one parameter 'switches places' with an estimate for another, as can occur when different chains or iterations identify opposite modes as the 'primary mode'.
The shape of the probability density function for a bimodal distribution also depends on the combination of concentration ($\kappa$) and proportion (in `brms` $\theta$) at each mode.
This introduces an additional challenge for identifiability, since low probability of observations near a mode may result from that mode having low concentration or a small proportion of the data, or both.

## Bimodality of differences and dances

In this dataset, dances during the 'UV dim' condition are typically separated from those under the 'UV bright' condition by $\pm90°$.
For most dances a single primary mode can be found can be found to the left or right of the mean for the 'UV bright' condition, with approximately equal frequency.
For some dances, two modes occur to both the right and left of the 'UV bright' mode, with varying proportions of the data around either.

## Reducing uncertainty

Taken in isolation, the data for the 'UV dim' condition have relatively low concentration, and vary greatly in orientation as a function of sun azimuth (known) and advertised location (not known).
The direction of the advertised location can be estimated from the 'UV bright' condition, for which concentration was high, so this information can be used to reduce uncertainty about advertised direction.
Since dances by the same individual should generally have similar properties, a reasonable assumption would be that the concentration parameter $\kappa$ should be similar between the mode of the 'UV bright' dance and the 'UV dim' dance, after accounting for any population-level effect of decreased brightness.
Since leftwards and rightwards turns appear interchangeable (at least equally likely) it is also possible that the two modes for our bimodal turns, and bimodal dances, should have similar concentration.

## Step-by-step strategy

Ideally, the parameters associated with each of these assumptions would be estimated simultaneously within the same model.
Due to the aforementioned identifiability issues, it is preferable to first establish the plausible properties of each parameter under stricter assumptions, before attempting models with greater complexity.
Here, we will begin by establishing a model for just the 'UV bright' condition, and then a model for the change between the 'UV bright' and 'UV dim' conditions, starting with strong assumptions about the stability of $\kappa$ and $\theta$ across individuals and conditions, to determine a set of reasonable assumptions under which to identify the population-level bimodal effects of the change between bright and dim UV light.

# Set up workspace

Estimating these models, we need to load the appropriate functions.
Make sure that the `circular`, `cmdstanr` and `brms` are installed, and 
(on Windows) that you have installed the latest version of [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

```{r Load functions and packages}
source('GUV_functions.R')
```

Set up some colours for plotting.

```{r Set up plot colours}
col_kappa = '#1E78B5'#colour for kappa parameter
col_rho = '#F08024' #colour for mean vector length
col_sd = '#E74A29' #colour for SD and mean angle
col_sd2 = '#E57461' #colour for other SD heuristics
col_pdf = adjustcolor(col = '#21A885', # colour for probability density
                      alpha.f = 0.7)
col_obs = '#3E1F51' #colour for control observations
col_treat = '#006400' # colour for treatment observations
```

# Prepare data

Then load the data that will be used.
This is our dance data, reorganised by `GUV_organisedata.R` as `colour_dance_reorg.csv`.

```{r Load data}
#Dance angle data
cd = read.table(file = '1Data/colour_dance_reorg.csv', 
                header = T, 
                sep  = ',')
head(cd)
```

## Format data

Ensure that each variable has the correct data format for subsequent analysis.

```{r Data formatting}
cd = within(cd,
            {
              ID = as.factor(ID) # beedance identifier as a factor
              date = as.factor(date) # date as a factor
              signed_angle = Mod360.180(bearing)  # bearing between -180 and 180
              angle = circular(rad(signed_angle),# bearing between -pi and pi
                               rotation = 'clock') # circular format suppresses later warnings
            }
)
u_id = with(cd, unique(ID)) # unique beedances
length(u_id)#169 beedances
```
```{r Shorten variable names for modelling}
cd = within(cd,
            {
              BR = brightn
              CL = colour
              DT = date
              RN = run
            }
)
```

## Identify dances for both conditions
Identify dances in which all four stimulus conditions were used.

```{r both conditions}
uvc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              colour %in% 'u'),
                     {
                       length(unique(brightn))
                       }
                     )
              },
              dt = cd)

#There should be two brightness levels for UV
uv_ids = u_id[uvc == 2]
length(uv_ids)#most individuals
#extract just those individuals

#find data for full condition individuals
cd_uv = subset(cd, ID %in% uv_ids)
```

# Set up circular modelling

```{r Set up the circular model custom family}
#set up required Stan functions
#circular modulo in Stan code
modulo_circular_fun = stanvar(scode = "
  real modulo_circular(real y) {
    return fmod(y + pi(), 2*pi()) - pi();
  }
",
                           block = 'functions')

#custom likelihood function using the shifted modulo link
#additional function to account for vectors
stan_unwrap_fun = stanvar(scode = "
    real unwrap_von_mises_lpdf(real y, real mu, real kappa) {
      return von_mises_lpdf(y | modulo_circular(mu), kappa);
    }
    real unwrap_von_mises_rng(real mu, real kappa) {
      return von_mises_rng( modulo_circular(mu) , kappa);
    }
    real unwrap_von_mises_vect_lpdf(vector y, real mu, real kappa) {
    real tmp = 0;
    for(i in 1:size(y))
    {
    tmp = tmp + unwrap_von_mises_lpdf(y[i] | mu, kappa);
    }
      return tmp;
    }
  ",
                          block = 'functions')


#Introduce stan variable for kappamu
stan_softkappamu = stanvar(scode = "
real softkappamu;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mu = log1p_exp(softkappamu);
          ", 
          block = 'genquant')

#define the custom family
unwrap_von_mises = custom_family(
  name = "unwrap_von_mises",
  dpars = c("mu",
            "kappa"),
  links = c('identity',#N.B. the link function is defined via the LPD function
            "softplus"), 
  lb = c(-pi,#lower bound of mu should be -pi
         0),
  ub = c(pi,#upper bound of mu should be pi
         NA),
  type = "real",#takes continuous response data
)

```


```{r Set up plotting functions for circular estimates}

#add contours
Draws2Cont = function(draws,
                      palette = 'Heat 2',
                      nlevels = 20,
                      x_string = 'sin(Intercept)*A1(softplus(Intercept_kappa))',
                      y_string = 'cos(Intercept)*A1(softplus(Intercept_kappa))',
                      alpha = 200/255,
                      ngrid = 25, # defaults to a 25x25 grid
                      cropc = FALSE, #crop region outside circle
                      denstype = 'relative' # 'normalised' or 'relative' (normalised fails to plot low densities)
)
{
  kdc = with(draws,
             {
               MASS::kde2d(x = eval(str2lang(x_string)),
                           y = eval(str2lang(y_string)),
                           n = ngrid)
             }
  )
  if(cropc)
  {
    xy = with(kdc, expand.grid(x = x,y= y))#find coordinates of z variable
    idc = with(xy, x^2+y^2 < 1.0)
    #crop edge of circle
    kdc = within(kdc,
                 {z[!idc] = 0})
  }
  with(kdc,
       {
         .filled.contour(x = x,
                         y = y,
                         z = z,
                         levels = (1:nlevels)*
                           switch(EXPR = denstype,
                                  relative = max(z/nlevels),
                                  normalised = sum(z/nlevels),#warning, fails to plot low densities
                                  max(z/nlevels)
                           ),
                         col = hcl.colors(n = nlevels,
                                          palette = palette,
                                          rev = TRUE,
                                          alpha = alpha)
         )
       }
  )
}
```

# Model for UV Bright

Find data for the 'UV bright' condition.
```{r UV bright subset}
cd_uvh = subset(cd,
               colour %in% 'u' &
                 brightn %in% 'h')
id_uvh = with(cd_uvh, unique(ID))
length(id_uvh)#nearly all
```


## Set up formula and priors

In this model each individual dance may have a different preferred direction $\mu_i$
 relative to the population mean direction $\mu_0$. This is written explicitly as
 a nonlinear formula $\mu \sim \mu_0 + \mu_i$. Individuals may also differ in 
concentration, which is implied by the linear formula $\kappa \sim 1 + (1|ID)$.
```{r UV bright formula}

formula_uvh = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui), 
  mu0 ~ 1, # all conditions
  mui ~ 0 + ID, # mean angle combines fixed and random effects
  kappa ~  1 + (1 |ID), #for kappa this occurs in linear space, and BRMS can set it up automatically
  family = unwrap_von_mises,#mod mu, kappa via the softplus
  nl = TRUE)#to accept user-defined extra parameters (zmu) we need to treat the formula as nonlinear

```

This model requires priors that indicate the likely values of $\mu_0$ and $\kappa_0$,
as well as the likely relationships between $\kappa_i$ and implied hyperparameter $\sigma_\kappa$,
and defining a role for the hyperparameter $\kappa_\mu$, which was introduced 
in the Stan code above (in inverse-softplus space: $\kappa_\mu = \log(1 + \exp(\text{softkappamu})$).

```{r UV bright priors}

#priors for mu
pr_mu_uvh = prior('normal(0,3*pi()/2)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior(paste("target +=", 
                            'normal_lpdf(b_mui | 0, 2*pi())'# additional prior to keep estimates from walking around the circle
            ),
            check = FALSE) +
                  set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                            check = FALSE)

#priors for kappa
pr_kappa_uvh = 
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', dpar = 'kappa')
  
#all unimodal priors
pr_uvh = pr_mu_uvh + pr_kappa_uvh
```

## Run the model for UV bright

This model includes a lot of data and parameters, be prepared for it to take a 
long time to complete all iterations for all chains. Takes 20 minutes on a 2019 Macbook Pro.

```{r UV bright model}

#very long compile time
system.time(
  {
    
    model_uvh = brm(formula = formula_uvh,
                   data = cd_uvh,
                   prior = pr_uvh,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   silent = 2, # echo only high priority Stan messages
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/UV_high_model.RData',
     model_uvh)#save for future reference

```
## Inspect model estimates

This model identifies both a population level bias (near 0°) and individual biases
 with stable parameter estimates on the 'unwrapped' (circular modulo) scale.
 
```{r Inspect UV bright model}
load(file = '2Results/UV_high_model.RData')
#population kappa and its standard deviation
plot(model_uvh,
      ask = FALSE,
      variable = c('Intercept_kappa', 'sd', 'kappa_mu'),
      regex = TRUE) #plot raw estimates
#population directional bias
plot(model_uvh,
      ask = FALSE,
      variable = 'mu0',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates

```

The population level mean angle $\mu_0$ appears to oscillate gradually over the 
course of sampling. These oscillations do not appear to affect convergence 
heuristics, though they may affect sampling efficiency. Setting $\text{adapt_delta}>0.8$
 and increasing the length of warmup does not appear to prevent these oscillations. 
They likely result from uncertainty in the particular values of $\mu_i$ for each 
dance, and the effect of $\mu_i$ on likely values for $\mu_0$. In general, these 
oscillations appear symmetrical and uncorrelated across chains, as well as 
restricted to a narrow range of $\approx 15°$.
To reduce the influence of any particular oscillation on the final estimate the 
number of post-warmup samples has been increased to $2000$.

```{r Inspect individual means UV bright model}
#inidividual but they overlap when unwrapped
plot(x = model_uvh,
     variable = 'mui',
     regex = TRUE,
     ask = FALSE,
     transform = unwrap_circular_deg) #plot transformed estimates
```

Calculating the $\hat{R}$ values for unwrapped estimates for $\mu_i$ reveals that 
all estimates converged well ( $\hat{R}<1.01$).

```{r Convergence heuristics for the UV bright model}

sm_uvh = summary(model_uvh,
                 variable = c('Intercept_kappa', 'sd', 'kappa_mu'),
                regex = TRUE)
print(sm_uvh, digits = 2)
#mu0 and mui look bad, but good after unwrapping
UnwrapRhats(model_uvh,
            variable = '^b_mu0')
summary(UnwrapRhats(model_uvh,
            variable = '^b_mui') )
```

The estimates of $\kappa_\mu$ here have a slight positive bias, due to a combination of low sample size and our prior to higher values.
The model nonetheless recovers good estimates of $\mu_0$ and $\mu_i$.
Importantly, this also allows us to estimate population $\kappa$, that is the concentration of the average individual, which needs to be distinguished from individual differences and the concentration across individuals.


## Extract predictions for the UV high model

Since this model's estimates provide context for the 'UV dim' data, most importantly 
the directional bias for each individual dance, we need to extract the estimates 
for each individual before attempting the next model.


```{r Plot the UV bright model}
mu_id_uvh = rep(NA, length(id_uvh))
kappa_id_uvh = rep(NA, length(id_uvh))

draws_uvh = as_draws_df(model_uvh)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uvh) )
{
  mu_name = paste0('b_mui_ID',id_uvh[i])
  kappa_name = paste0('r_ID__kappa[',id_uvh[i],',Intercept]')
  with(subset(cd_uvh, ID %in% id_uvh[i]),
  {
    PCfun(angles = bearing,
         col = col_obs,
         plot_rho = FALSE)
    }
  )
  Draws2Cont(draws_uvh,
             x_string = 'sin(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))'
             )
  mu_id_uvh[i] = with(draws_uvh,
                      {
                        median.circular(
                             circular(x =
                             mod_circular(b_mu0_Intercept + get(mu_name)),
                                          template = 'none')
                                           )[1]
                      })
  kappa_id_uvh[i] = with(draws_uvh,
                         {softplus(median(Intercept_kappa+get(kappa_name)))} )
  
  arrows.circular(x = circular(x = mu_id_uvh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_uvh[i]),
                 lwd = 5,
                 length = 0.1/1.25,
                 col = adjustcolor(col_sd, alpha.f = 200/255))
}
#Add the population of biases
# 
par(mfrow = c(1,3))
PCfun(angles = deg(mu_id_uvh),
      col = col_rho,
      shrink = 2,
      plot_rho = FALSE)
Draws2Cont(draws = draws_uvh,
           x_string = 'sin(b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept)*
             A1(kappa_mu)'
           )

with(draws_uvh,
     arrows.circular(x = mean.circular(circular(b_mu0_Intercept,
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2)
     )[1],
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor(col_sd, alpha.f = 200/255))
)


with(draws_uvh,
     VertHist(data = softplus(Intercept_kappa), 
              main = '\npopulation kappa',
              ylim = c(0, 15),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)
with(draws_uvh,
     VertHist(data = kappa_mu, 
              main = '\npopulation kappamu',
              ylim = c(0, 5),
              col = adjustcolor(col_sd, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5)
```


# Model for bimodal change

## Prepare data

Subtract estimated mean for 'UV bright' dances from dance angles for 'UV dim'.

```{r Calculate change data}
cd_change = within(cd_uv,
                   {
                   change_angle = mapply(FUN = function(id, ang)
                                   {
                                   ii = which(id_uvh %in% id)
                                   return( mod_circular(ang - mu_id_uvh[ii]) )
                                 },
                                 id = ID,
                                 ang = angle
                                 )
                   }
)
#select only the UV dim data
cd_change = subset(cd_change,
               colour %in% 'u' &
                 brightn %in% 'l'
                   )
```

## Inspect data

While the size of the change varies greatly across individuals, many have their 
near $\pm 90°$, that is a quarter turn to left or right. This is clearest for the
 group of 19 dances that included all stimuli, but more broadly discernable across 
 the rest of the dataset.
In addition, a subset of individuals exhibit (axial) bimodality, with a secondary 
mean approximately 180° from the primary mean.

```{r Plot the estimated change data}
id_uv = with(cd_uv, unique(ID))
calc_mu = rep(NA, length(id_uv))
par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uv) )
{
  with(subset(cd_change, ID %in% id_uv[i]),
  {
    PCfun(angles = deg(change_angle),
         col = col_sd2)}
  )
  calc_mu[i] = with(subset(cd_change, ID %in% id_uv[i]),
                    {mean.circular(x = circular(change_angle, template = 'none'))}
                    )
}
# 
par(mfrow = c(1,2))
PCfun(angles = deg(calc_mu),
      col = col_rho,
      shrink = 2)

#full condition individuals used for mean vector analysis
u_id = with(cd, unique(ID))
luc = sapply(u_id,
              FUN = IndCond,
              dt = cd)

#Most individuals that made it to bright green 
full_ids = u_id[luc == 4]

PCfun(angles = deg(calc_mu[which(full_ids %in% uv_ids)]),
      col = col_kappa,
      shrink = 2)

mean(calc_mu<0)
```



## Set up formula and priors

The simplest possible model for a bimodal distribution with individual effects, 
needs to account for individual differences in primary mode and concentration. 
For simplicity, here it is assumed that individual differences affect the primary
 and secondary mode (separated by approximately 180°) identically, and that 
both modes have the same concentration $\kappa_1 = \kappa_2 = \log(1+\exp(k_1))$. 

```{r Change formula}

formula_change = bf(#modulus may not be necessary, included in lpd function
  formula = change_angle ~ mu,
  nlf(mu1 ~ mu0 + mui), #primary mean, population mean plus individual mean
  nlf(mu2 ~ mu0 + mub + mui), #secondary mean, population mean plus offset, plus individual mean
  mu0 ~ 1, #primary mean
  mui ~ 0 + ID, # mean angle combines fixed and random effects
  mub ~ 1, #angle between primary mean and secondary mean
  nlf(kappa1 ~ k1), #concentration for primary mean
  nlf(kappa2 ~ k1), #concentration for secondary mean
  k1 ~ 1 + (1 |ID), #for kappa this occurs in linear space, and BRMS can set it up automatically
  theta1 ~ 1 + (1 |ID), #for mixture weighting, this is specific to individual and condition combination
  family = mixture(unwrap_von_mises,#primary mean distribution
                   unwrap_von_mises #secondary mean distribution
  ),#mixture, specified by the log ratio of theta1 : theta2
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear
```

This model requires priors additional priors for $\mu_1$ and $\kappa_2$. For a 
near axial bimodal distribution the expectation would be that $\mu_1$ and $\mu_2$
 are separated by ≈180°, so the prior for $\mu_\beta$ is set to this value. For this 
formula, $\kappa_1$ and $\kappa_2$ are both set deterministically by the parameter
 `k1`, so both can take the same prior.
Note that values of $\mu_i$ estimated for this dataset account only for individual 
deviations in turn angle, since individual directional preferences estimated for 
the UV bright stimulus have already been subtracted. This may introduce excess 
uncertainty about the particular values of $\mu_i$, so the shrinkage towards no 
difference enforced by $\kappa_\mu$ is important for stability.
In a bimodal model, $\mu_1$ and $\mu_2$ can become indistinguishable, so we also 
need tighter priors for `mu0` and `mub` to ensure that their estimates do not 
switch places. Since there appear to be more individuals with a leftwards turn 
we a negative prior for `mu0` and a positive one for `mub`.
One additional safeguard would be to ensure that $\mu_1$ is also in the direction 
that includes the most data, as would be the case for the leftwards mode. This can 
be implied by biasing $\theta_1$ towards positive values. The data itself implies 
a value around `1.0` (`qlogis(mean(calc_mu<0))`), but when estimates cross 0 the 
modes may switch roles, such that there would also be a stable estimate at `-1.0`.

```{r change priors}

#priors for mu
pr_mu_change = prior('normal(-pi()/2, pi()/6)', class = 'b', nlpar = 'mu0') +
                prior('normal(pi(), pi()/6)', class = 'b', nlpar = 'mub') + #expected offset of ≈180°
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior(paste("target +=", 
                            'normal_lpdf(b_mui | 0, 2*pi())'# additional prior to keep estimates from walking around the circle
            ),
            check = FALSE) +
                  set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                            check = FALSE)

#priors for kappa
pr_kappa_change = 
                  prior('normal(3,3)', class = 'b', nlpar = 'k1') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', nlpar = 'k1')

#priors for theta
pr_theta_change = 
                  prior('normal(3, 0.5)', class = 'Intercept', dpar = 'theta1') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', dpar = 'theta1')
  
#all unimodal priors
pr_change = pr_mu_change + pr_kappa_change+ pr_theta_change
```

## Run the model for bimodal change

```{r change model}

#very long compile time
system.time(
  {
    
    model_change = brm(formula = formula_change,
                   data = cd_change,
                   prior = pr_change,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 500, #
                   iter = 1000, # longer sampling to efficiently sample mu0
                   silent = 2, # echo only high priority Stan messages
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/UV_change_model.RData',
     model_change)#save for future reference

```

## Inspect model estimates

This model identifies both a population level bias (near 0°) and individual biases
 with stable parameter estimates on the 'unwrapped' (circular modulo) scale.
 
```{r Inspect UV bright model}
load(file = '2Results/UV_change_model.RData')
#population kappa and its standard deviation
plot(model_change,
      ask = FALSE,
      variable = c('Intercept_kappa', 'theta1_Intercept', 'sd', 'kappa_mu'),
      regex = TRUE) #plot raw estimates
#population directional bias
plot(model_change,
      ask = FALSE,
      variable = 'mu0',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates
#population level change in direction
plot(model_change,
      ask = FALSE,
      variable = 'mub',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates

```

The population level mean angle $\mu_0$ appears to oscillate gradually over the 
course of sampling. These oscillations do not appear to affect convergence 
heuristics, though they may affect sampling efficiency. Setting $\text{adapt_delta}>0.8$
 and increasing the length of warmup does not appear to prevent these oscillations. 
They likely result from uncertainty in the particular values of $\mu_i$ for each 
dance, and the effect of $\mu_i$ on likely values for $\mu_0$. In general, these 
oscillations appear symmetrical and uncorrelated across chains, as well as 
restricted to a narrow range of $\approx 15°$.
To reduce the influence of any particular oscillation on the final estimate the 
number of post-warmup samples has been increased to $2000$.

```{r Inspect individual means change model}
#inidividual but they overlap when unwrapped
plot(x = model_change,
     variable = 'mui',
     regex = TRUE,
     ask = FALSE,
     transform = unwrap_circular_deg) #plot transformed estimates
```

Calculating the $\hat{R}$ values for unwrapped estimates for $\mu_i$ reveals that 
all estimates converged well ( $\hat{R}<1.01$).

```{r Convergence heuristics for the change model}

sm_change = summary(model_change,
                 variable = c('Intercept_kappa', 'theta1_Intercept',
                              'sd', 'kappa_mu'),
                regex = TRUE)
print(sm_change, digits = 2)
#mu0 and mui look bad, but good after unwrapping
UnwrapRhats(model_change,
            variable = '^b_mu0')
UnwrapRhats(model_change,
            variable = '^b_mub')
summary(UnwrapRhats(model_change,
            variable = '^b_mui') )
```


## Extract predictions for the UV change model

```{r Plot the change model}
mu1_id_change = rep(NA, length(id_uv))
mu2_id_change = rep(NA, length(id_uv))
kappa_id_change = rep(NA, length(id_uv))
theta_id_change = rep(NA, length(id_uv))

draws_change = as_draws_df(model_change)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uv) )
{
  mu_name = paste0('b_mui_ID',id_uv[i])
  kappa_name = paste0('r_ID__k1[',id_uv[i],',Intercept]')
  theta_name = paste0('r_ID__theta1[',id_uv[i],',Intercept]')
  with(subset(cd_change, ID %in% id_uv[i]),
  {
    PCfun(angles = bearing,
         col = col_obs,
         plot_rho = FALSE)
    }
  )
  #primary mean
  Draws2Cont(draws_change,
             x_string = 'sin(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             palette = 'Red-Yellow' 
             )
  #secondary mean
  Draws2Cont(draws_change,
             x_string = 'sin(b_mu0_Intercept + b_mub_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + b_mub_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             palette = 'Blue-Yellow' 
             )
  mu1_id_change[i] = with(draws_change,
                      {
                        median.circular(
                             circular(x =
                             mod_circular(b_mu0_Intercept + get(mu_name)),
                                          template = 'none')
                                           )[1]
                      })
  mu2_id_change[i] = with(draws_change,
                      {
                        median.circular(
                             circular(x =
                             mod_circular(b_mu0_Intercept + b_mub_Intercept + get(mu_name)),
                                          template = 'none')
                                           )[1]
                      })
  kappa_id_change[i] = with(draws_change,
                         {softplus(median(b_k1_Intercept+get(kappa_name)))} )
  theta_id_change[i] = with(draws_change,
                         {plogis(median(b_theta1_Intercept+get(theta_name)))} )
  #primary mean
  arrows.circular(x = circular(x = mu1_id_change[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_change[i]),
                 lwd = 5*plogis(theta_id_change[i]),
                 length = 0.1/1.25,
                 col = adjustcolor(col_rho, alpha.f = 200/255))
  #secondary mean
  arrows.circular(x = circular(x = mu2_id_change[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_change[i]),
                 lwd = 5*plogis(-theta_id_change[i]),
                 length = 0.1/1.25,
                 col = adjustcolor(col_rho, alpha.f = 200/255))
}
#Add the population of biases
par(mfrow = c(1,3))
PCfun(angles = deg(calc_mu),
      col = col_rho,
      plot_rho = FALSE)
# PCfun(angles = deg(mu1_id_change),
#       col = col_rho,
#       plot_rho = FALSE)
Draws2Cont(draws = draws_change,
           x_string = 'sin(b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept)*
             A1(kappa_mu)',
           palette = 'Red-Yellow'
           )
Draws2Cont(draws = draws_change,
           x_string = 'sin(b_mu0_Intercept+b_mub_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept+b_mub_Intercept)*
             A1(kappa_mu)',
           palette = 'Blue-Yellow'
           )

with(draws_change,
     arrows.circular(x = mean.circular(circular(b_mu0_Intercept,
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2)
     )[1],
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor(col_sd, alpha.f = 200/255))
)


with(draws_change,
     VertHist(data = softplus(b_k1_Intercept), 
              main = '\npopulation kappa',
              ylim = c(0, 15),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)
with(draws_change,
     VertHist(data = kappa_mu, 
              main = '\npopulation kappamu',
              ylim = c(0, 5),
              col = adjustcolor(col_sd, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5)
```


# Model for symmetrical change

It is also possible that the secondary mode is not 180° from the primary one for 
all individuals. In fact, this is quite likely for individuals that do not change 
by precisely $\pm 90°$, since the ambiguity about the sun's position relative to 
the stimulus, more specifically whether it falls at a particular angle to the left 
or right of the stimulus. This would depend specifically on the value of $\mu_i$ 
for that individual, if the primary mean falls at $\mu_1 = \mu_0 + \mu_i$,  the 
secondary mean should fall at $\mu_2 = -(\mu_0 + \mu_i)$. In that case, we can 
exclude the $\mu_\beta$ parameter, though if there are large deviations from 
symmetry, we could account for these by introducing another parameter, $\mu_{i,\beta}$,
so that $\mu_2 = -(\mu_0 + \mu_i + \mu_{i,\beta})$.

## Set up formula and priors

```{r Symmetry formula}

formula_symm = bf(#modulus may not be necessary, included in lpd function
  formula = change_angle ~ mu,
  nlf(mu1 ~ mu0 + mui), #primary mean, population mean plus individual mean
  nlf(mu2 ~ -(mu0 + mui) ), #secondary mean, population mean plus offset, plus individual mean
  mu0 ~ 1, #primary mean
  mui ~ 0 + ID, # mean angle combines fixed and random effects
  nlf(kappa1 ~ k1), #concentration for primary mean
  nlf(kappa2 ~ k1), #concentration for secondary mean
  k1 ~ 1 + (1 |ID), #for kappa this occurs in linear space, and BRMS can set it up automatically
  theta1 ~ 1 + (1 |ID), #for mixture weighting, this is specific to individual and condition combination
  family = mixture(unwrap_von_mises,#primary mean distribution
                   unwrap_von_mises #secondary mean distribution
  ),#mixture, specified by the log ratio of theta1 : theta2
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear
```


```{r Symmetry priors}

#priors for mu
pr_mu_symm = prior('normal(-pi()/2, pi()/6)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior(paste("target +=", 
                            'normal_lpdf(b_mui | 0, 2*pi())'# additional prior to keep estimates from walking around the circle
            ),
            check = FALSE) +
                  set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                            check = FALSE)

#priors for kappa
pr_kappa_symm = 
                  prior('normal(3,3)', class = 'b', nlpar = 'k1') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', nlpar = 'k1')

#priors for theta
pr_theta_symm = 
                  prior('normal(3,0.5)', class = 'Intercept', dpar = 'theta1') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', dpar = 'theta1')
  
#all unimodal priors
pr_symm = pr_mu_symm + pr_kappa_symm + pr_theta_symm
```


## Run the model for symmetrical change

```{r symmetry model}

#very long compile time
system.time(
  {
    
    model_symm = brm(formula = formula_symm,
                   data = cd_change,
                   prior = pr_symm,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
 
                   silent = 2, # echo only high priority Stan messages
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/UV_symm_model.RData',
     model_symm)#save for future reference

```

## Inspect model estimates

This model identifies both a population level bias (near 0°) and individual biases
 with stable parameter estimates on the 'unwrapped' (circular modulo) scale.
 
```{r Inspect symmetrical change model}
load(file = '2Results/UV_symm_model.RData')
#population kappa and its standard deviation
plot(model_symm,
      ask = FALSE,
      variable = c('Intercept_kappa', 'theta1_Intercept', 'sd', 'kappa_mu'),
      regex = TRUE) #plot raw estimates
#population directional bias
plot(model_symm,
      ask = FALSE,
      variable = 'mu0',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates
#population level change in direction

```

The

```{r Inspect individual means symmetrical model}
#inidividual but they overlap when unwrapped
plot(x = model_symm,
     variable = 'mui',
     regex = TRUE,
     ask = FALSE,
     transform = unwrap_circular_deg) #plot transformed estimates
```

Calculating the $\hat{R}$ values for unwrapped estimates for $\mu_i$ reveals that 
all estimates converged well ( $\hat{R}<1.01$).

```{r Convergence heuristics for the symmetry model}

sm_symm = summary(model_symm,
                 variable = c('Intercept_kappa', 'sd', 'kappa_mu'),
                regex = TRUE)
print(sm_symm, digits = 2)
#mu0 and mui look bad, but good after unwrapping
UnwrapRhats(model_symm,
            variable = '^b_mu0')
summary(UnwrapRhats(model_symm,
            variable = '^b_mui') )
```



## Extract predictions for the symmetrical change model

```{r Plot the symmetrical change model}
mu1_id_symm = rep(NA, length(id_uv))
mu2_id_symm = rep(NA, length(id_uv))
kappa_id_symm = rep(NA, length(id_uv))
theta_id_symm = rep(NA, length(id_uv))

draws_symm = as_draws_df(model_symm)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,5) )
for(i in 1:length(id_uv) )
{
  mu_name = paste0('b_mui_ID',id_uv[i])
  kappa_name = paste0('r_ID__k1[',id_uv[i],',Intercept]')
  theta_name = paste0('r_ID__theta1[',id_uv[i],',Intercept]')
  with(subset(cd_change, ID %in% id_uv[i]),
  {
    PCfun(angles = bearing,
         col = col_obs,
         plot_rho = FALSE)
    }
  )
  #primary mean
  Draws2Cont(draws_symm,
             x_string = 'sin(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             palette = 'Red-Yellow' 
             )
  #secondary mean
  Draws2Cont(draws_symm,
             x_string = 'sin(-(b_mu0_Intercept + get(mu_name)))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             y_string = 'cos(-(b_mu0_Intercept + get(mu_name)))*
                         A1(softplus(b_k1_Intercept+get(kappa_name)))',
             palette = 'Blue-Yellow' 
             )
  mu1_id_symm[i] = with(draws_symm,
                      {
                        median.circular(
                             circular(x =
                             mod_circular(b_mu0_Intercept + get(mu_name)),
                                          template = 'none')
                                           )[1]
                      })
  mu2_id_symm[i] = with(draws_symm,
                      {
                        median.circular(
                             circular(x =
                             mod_circular( -(b_mu0_Intercept + get(mu_name)) ),
                                          template = 'none')
                                           )[1]
                      })
  kappa_id_symm[i] = with(draws_symm,
                         {softplus(median(b_k1_Intercept+get(kappa_name)))} )
  theta_id_symm[i] = with(draws_symm,
                         {plogis(median(b_theta1_Intercept+get(theta_name)))} )
  #primary mean
  arrows.circular(x = circular(x = mu1_id_symm[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_symm[i]),
                 lwd = 5*plogis(theta_id_symm[i]),
                 length = 0.1/1.25,
                 col = adjustcolor(col_rho, alpha.f = 200/255))
  #secondary mean
  arrows.circular(x = circular(x = mu2_id_symm[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_symm[i]),
                 lwd = 5*plogis(-theta_id_symm[i]),
                 length = 0.1/1.25,
                 col = adjustcolor(col_rho, alpha.f = 200/255))
}
#Add the population of biases
par(mfrow = c(1,3))
PCfun(angles = deg(calc_mu),
      col = col_rho,
      plot_rho = FALSE)
# PCfun(angles = deg(mu1_id_symm),
#       col = col_rho,
#      plot_rho = FALSE)
Draws2Cont(draws = draws_symm,
           x_string = 'sin(b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept)*
             A1(kappa_mu)',
           palette = 'Red-Yellow'
           )
Draws2Cont(draws = draws_symm,
           x_string = 'sin(-b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(-b_mu0_Intercept)*
             A1(kappa_mu)',
           palette = 'Blue-Yellow'
           )

with(draws_symm,
     arrows.circular(x = mean.circular(circular(b_mu0_Intercept,
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2)
     )[1],
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor(col_sd, alpha.f = 200/255))
)


with(draws_symm,
     VertHist(data = softplus(b_k1_Intercept), 
              main = '\npopulation kappa',
              ylim = c(0, 15),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)
with(draws_symm,
     VertHist(data = kappa_mu, 
              main = '\npopulation kappamu',
              ylim = c(0, 5),
              col = adjustcolor(col_sd, alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5)
```
