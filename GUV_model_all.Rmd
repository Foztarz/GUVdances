---
title: "GUV_model_figure"
author: "James Foster"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    fig_caption: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Details

**DESCRIPTION**

Fit and plot circular GLMs to describe all four stimulus conditions.

**INPUTS**

`GUV_functions.R`

**OUTPUTS**

Models and plotted estimates.

**REFERENCES**

**Experimental approach**

Edrich W, Neumeyer C & von Helversen, O.
(1979) “Anti-sun orientation” of bees with regard to a field of ultraviolet light.
*J. Comp. Physiol.* 134, 151–157.

Rossel, S.
& Wehner, R.
(1984).
Celestial orientation in bees: the use of spectral cues.
*J. Comp. Physiol. A* 155, 605–613.

**modelling methods**

Sayin S, Couzin-Fuchs E, Petelski I, Günzel Y, Salahshour M, Lee CY, Graving JM, Li L, Deussen O, Sword GA, et al. (2025) The behavioral mechanisms governing collective motion in swarming locusts.
*Science* 387(6737):995–791

Gabry J, Češnovar R, Johnson A (2022).
cmdstanr: R Interface to 'CmdStan'.
<https://mc-stan.org/cmdstanr/>

Bürkner, P.-C.
(2018).
Advanced Bayesian Multilevel Modeling with the R Package brms.
*The R Journal* 10, 395–411.

Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P. and Riddell, A.
(2017).
Stan: A Probabilistic Programming Language.
*Journal of Statistical Software* 76 doi: 10.18637/jss.v076.i01

Vehtari, A., Gelman, A., and Gabry, J.
(2017) Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.
*Statistics and Computing* 27(5), 1413–1432.
<doi:10.1007/s11222-016-9696-4>.

Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A.
(2021).
Implicitly adaptive importance sampling.
*Statistics and Computing* 31, 16.
<doi:10.1007/s11222-020-09982-2>.

# Motivation


# Set up workspace

Estimating these models, we need to load the appropriate functions.
Make sure that the `circular`, `cmdstanr` and `brms` are installed, and 
(on Windows) that you have installed the latest version of [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

```{r Load functions and packages}
source('GUV_functions.R')
```

Set up some colours for plotting.

```{r Set up plot colours}
col_kappa = '#1E78B5'#colour for kappa parameter
col_rho = '#F08024' #colour for mean vector length
col_sd = '#E74A29' #colour for SD and mean angle
col_sd2 = '#E57461' #colour for other SD heuristics
col_pdf = adjustcolor(col = '#21A885', # colour for probability density
                      alpha.f = 0.7)
col_obs = '#3E1F51' #colour for control observations
col_treat = '#006400' # colour for treatment observations
```

# Prepare data

Then load the data that will be used.
This is our dance data, reorganised by `GUV_organisedata.R` as `colour_dance_reorg.csv`.

```{r Load data}
#Dance angle data
cd = read.table(file = '1Data/colour_dance_reorg.csv', 
                header = T, 
                sep  = ',')
head(cd)
```

## Format data

Ensure that each variable has the correct data format for subsequent analysis.

```{r Data formatting}
cd = within(cd,
            {
              ID = as.factor(ID) # beedance identifier as a factor
              date = as.factor(date) # date as a factor
              signed_angle = Mod360.180(bearing)  # bearing between -180 and 180
              angle = circular(rad(signed_angle),# bearing between -pi and pi
                               rotation = 'clock') # circular format suppresses later warnings
            }
)
u_id = with(cd, unique(ID)) # unique beedances
length(u_id)#169 beedances
```
```{r Shorten variable names for modelling}
cd = within(cd,
            {
              BR = brightn
              CL = colour
              DT = date
              RN = run
            }
)
```

## Identify dances for both conditions
Identify dances in which all four stimulus conditions were used.

```{r both conditions}
uvc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              colour %in% 'u'),
                     {
                       length(unique(brightn))
                       }
                     )
              },
              dt = cd)

#There should be two brightness levels for UV
uv_ids = u_id[uvc == 2]
length(uv_ids)#most individuals
#extract just those individuals

#find data for full condition individuals
cd_uv = subset(cd, ID %in% uv_ids)
```

# Set up circular modelling

```{r Set up the circular model custom family}
#set up required Stan functions
#circular modulo in Stan code
modulo_circular_fun = stanvar(scode = "
  real modulo_circular(real y) {
    return fmod(y + pi(), 2*pi()) - pi();
  }
",
                           block = 'functions')

#custom likelihood function using the shifted modulo link
#additional function to account for vectors
stan_unwrap_fun = stanvar(scode = "
    real unwrap_von_mises_lpdf(real y, real mu, real kappa) {
      return von_mises_lpdf(y | modulo_circular(mu), kappa);
    }
    real unwrap_von_mises_rng(real mu, real kappa) {
      return von_mises_rng( modulo_circular(mu) , kappa);
    }
    real unwrap_von_mises_vect_lpdf(vector y, real mu, real kappa) {
    real tmp = 0;
    for(i in 1:size(y))
    {
    tmp = tmp + unwrap_von_mises_lpdf(y[i] | mu, kappa);
    }
      return tmp;
    }
  ",
                          block = 'functions')


#Introduce stan variable for kappamu
stan_softkappamu = stanvar(scode = "
real softkappamu;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mu = log1p_exp(softkappamu);
          ", 
          block = 'genquant')

#Introduce stan variable for kappamu - b
stan_softkappamub = stanvar(scode = "
real softkappamub;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mub = log1p_exp(softkappamu + softkappamub);
          ", 
          block = 'genquant')

#Introduce stan variable for kappamu - c
stan_softkappamuc = stanvar(scode = "
real softkappamuc;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_muc = log1p_exp(softkappamu + softkappamuc);
          ", 
          block = 'genquant')
#Introduce stan variable for kappamu - b:c
stan_softkappamubc = stanvar(scode = "
real softkappamubc;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mubc = log1p_exp(softkappamu + softkappamubc);
          ", 
          block = 'genquant')

#define the custom family
unwrap_von_mises = custom_family(
  name = "unwrap_von_mises",
  dpars = c("mu",
            "kappa"),
  links = c('identity',#N.B. the link function is defined via the LPD function
            "softplus"), 
  lb = c(-pi,#lower bound of mu should be -pi
         0),
  ub = c(pi,#upper bound of mu should be pi
         NA),
  type = "real",#takes continuous response data
)

```


```{r Set up plotting functions for circular estimates}

#add contours
Draws2Cont = function(draws,
                      palette = 'Heat 2',
                      nlevels = 20,
                      x_string = 'sin(Intercept)*A1(softplus(Intercept_kappa))',
                      y_string = 'cos(Intercept)*A1(softplus(Intercept_kappa))',
                      alpha = 200/255,
                      ngrid = 25, # defaults to a 25x25 grid
                      cropc = FALSE, #crop region outside circle
                      denstype = 'relative' # 'normalised' or 'relative' (normalised fails to plot low densities)
)
{
  kdc = with(draws,
             {
               MASS::kde2d(x = eval(str2lang(x_string)),
                           y = eval(str2lang(y_string)),
                           n = ngrid)
             }
  )
  if(cropc)
  {
    xy = with(kdc, expand.grid(x = x,y= y))#find coordinates of z variable
    idc = with(xy, x^2+y^2 < 1.0)
    #crop edge of circle
    kdc = within(kdc,
                 {z[!idc] = 0})
  }
  with(kdc,
       {
         .filled.contour(x = x,
                         y = y,
                         z = z,
                         levels = (1:nlevels)*
                           switch(EXPR = denstype,
                                  relative = max(z/nlevels),
                                  normalised = sum(z/nlevels),#warning, fails to plot low densities
                                  max(z/nlevels)
                           ),
                         col = hcl.colors(n = nlevels,
                                          palette = palette,
                                          rev = TRUE,
                                          alpha = alpha)
         )
       }
  )
}
```

# Model for unimodal conditions

For the two bright stimuli, and the dim green stimulus, all changes between stimuli
appear to be unimodal. This allows us to model both the dances and changes in dances
using a unimodal distribution. To account for individual differences in dance bias,
we include a parameter $\mu_i$, and which may also differ for different conditions.

```{r Binomial condition labels}
cd_all = cd

#include a code for the UV dim stimulus
cd_all = within(cd_all,
                {
                B = ifelse(BR == 'l', yes = 1, no = 0)
                C = ifelse(CL == 'u', yes = 1, no = 0)
                BC = ifelse(CL == 'u' & BR == 'l', yes = 1, no = 0)
                }
                )

```

## Set up formula and priors


```{r Unimodal change formula}

#this doesn't work because it introduces extra means for the intercept condition
formula_all = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui +muib +muic +muibc), #primary mean, population mean plus individual mean
  mu0 ~ 1 + B + C + BC, #population level effects
  mui ~ 0 + ID, # individual mu offset 
  muib ~ 0 + B:ID, # individual mu offset for brightness
  muic ~ 0 + C:ID, # individual mu offset for uv
  muibc ~ 0 + BC:ID, # individual mu offset for uv dim
  kappa ~ 1 + B + C + BC + (1 + B + C + BC | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

```

kappa_sd T(3,0,2) -> T(3,0,1) 
[mu0_Intercept N(0,pi) -> N(0,pi/2)] : there is a lot of data on this but seems low gradient
```{r Unimodal change priors}

#priors for mu
pr_mu_all = prior('normal(0, pi()/2)', coef = 'Intercept', nlpar = 'mu0') +
                  prior('normal(0, pi()/2)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                      check = FALSE)  +
  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu + softkappamub))',
                        nlpar  = 'muib',  class = 'b') +
            set_prior("target += normal_lpdf(softkappamub | 0, 1.0)", #expect small differences 
                      check = FALSE)  +
  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu + softkappamuc))',
                        nlpar  = 'muic',  class = 'b') +
            set_prior("target += normal_lpdf(softkappamuc | 0, 1.0)", #expect small differences 
                      check = FALSE) +
  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu + softkappamubc))',
                        nlpar  = 'muibc',  class = 'b') +
            set_prior("target += normal_lpdf(softkappamubc | 0, 1.0)", #expect small differences 
                      check = FALSE)  

#priors for kappa
pr_kappa_all = 
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') +
                  prior('student_t(3, 0, 1.0)', class = 'sd', dpar = 'kappa')

  
#all bimodal priors
pr_all = pr_mu_all + pr_kappa_all
```

## Run the model for individual deviations in bimodal change

For all individuals, expect this to take around 6 hours!
```{r individual change model}

#very long compile time
system.time(
  {
    
    model_all = brm(formula = formula_all,
                   # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = cd_all,
                   prior = pr_all,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu + 
                     stan_softkappamub + 
                     stan_softkappamuc + 
                     stan_softkappamubc,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), # Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/all_model.RData',
     model_all)#save for future reference

```


## Inspect model estimates

This model identifies both a population level bias (near 0°) and individual biases
 with stable parameter estimates on the 'unwrapped' (circular modulo) scale.
 
```{r Inspect unimodal change model}
load(file = '2Results/all_model.RData')
#population kappa and its standard deviation
plot(model_all,
      ask = FALSE,
      variable = c('kappa_Intercept', 'kappa_mu'),
      regex = TRUE) #plot raw estimates
#population directional bias
plot(model_all,
      ask = FALSE,
      variable = 'mu0',
      regex = TRUE,
     transform = unwrap_circular_deg) #plot transformed estimates
```



```{r Inspect individual means unimodal change model}
#individual but they overlap when unwrapped
plot(x = model_all,
     variable = 'mui',
     regex = TRUE,
     ask = FALSE,
     transform = unwrap_circular_deg) #plot transformed estimates
```

Calculating the $\hat{R}$ values for unwrapped estimates for $\mu_i$ reveals that 
all estimates converged well ( $\hat{R}<1.01$).

```{r Convergence heuristics for the change model}

sm_all = summary(model_all)
# print(sm_all$fixed[c(1,5:6+20),], digits = 3)
print(sm_all$fixed[c(1:2,5:6+length(u_id)),], digits = 3)
print(sm_all$random, digits = 3)
print(sm_all$spec_pars, digits = 3)

#mu0 and mui look bad, but good after unwrapping
UnwrapRhats(model_all,
            variable = '^b_mu0')
summary(UnwrapRhats(model_all,
            variable = '^b_mui') )
```

## Extract predictions

```{r set up functions to summarise draws}

#A function to find the circular median in (-pi, pi)
MedCDraws = function(x,
                     templ = 'none',
                     medn = 1)
{
  median.circular( circular(x = mod_circular(x),
                            template = templ)
                                           )[medn]
}
QCDraws = function(x,
                   probs = c(0.025, 0.5, 0.975),
                     templ = 'none',
                     medn = 1)
{
  quantile.circular( circular(x = mod_circular(x),
                            template = templ),
                     probs = probs
                                           )
}
```

```{r Plot the unimodal model}

#green high
mu_id_gh = rep(NA, length(u_id))
kappa_id_gh = rep(NA, length(u_id))

#UV high
mu_id_uh = rep(NA, length(u_id))
kappa_id_uh = rep(NA, length(u_id))

#green dim
mu_id_gl = rep(NA, length(u_id))
kappa_id_gl = rep(NA, length(u_id))

#UV dim
mu_id_ul = rep(NA, length(u_id))
kappa_id_ul = rep(NA, length(u_id))

draws_all = as_draws_df(model_all)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(4,4) )
# for(i in 1:length(u_id) )
for(i in 1:20 )
{
  mu_name = as.name(paste0('b_mui_ID',u_id[i]))
  mub_name =  as.name(paste0('b_muib_B:ID',u_id[i]))
  muc_name =  as.name(paste0('b_muic_C:ID',u_id[i]))
  mubc_name =  as.name(paste0('b_muibc_BC:ID',u_id[i]))
  kappa_name =  as.name(paste0('r_ID__kappa[',u_id[i],',Intercept]'))
  kappab_name =  as.name(paste0('r_ID__kappa[',u_id[i],',B]'))
  kappac_name =  as.name(paste0('r_ID__kappa[',u_id[i],',C]'))
  kappabc_name =  as.name(paste0('r_ID__kappa[',u_id[i],',BC]'))
  
  #proxy for awkward names
  # b_mu0_BRlClu_name = as.name("b_mu0_BRl:Clu")
  # b_kappa_BRlCLu_name = as.name("b_kappa_BRl:CLu")
  
  #green high
  with(subset(cd_all, 
              ID %in% u_id[i] &
                CL %in% 'g' & BR %in% 'h'),
  {
    PCfun(angles = bearing,
         col = 'green3',
         plot_rho = FALSE,
         title = u_id[i])
    }
  )
  Draws2Cont(draws_all,
             x_string = 'sin(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa +get(kappa_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))'
             )
  mu_id_gh[i] = with(draws_all,
                      {
                        MedCDraws(b_mu0_Intercept + get(mu_name))
                      })
  kappa_id_gh[i] = with(draws_all,
                         {softplus(median(Intercept_kappa+get(kappa_name)))} )
  
  arrows.circular(x = circular(x = mu_id_gh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gh[i]),
                 lwd = 5,
                 length = 0.1/1.25,
                 col = adjustcolor('green3', alpha.f = 200/255))
  #UV high
  with(subset(cd_all, 
              ID %in% u_id[i] &
                CL %in% 'u' & BR %in% 'h'),
  {
    PCfun(angles = bearing,
         col = 'magenta3',
         plot_rho = FALSE,
         title = u_id[i])
    }
  )
  Draws2Cont(draws_all,
             x_string = 'sin(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_C + get(muc_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name) +
                                       b_kappa_C +get(kappac_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name) + 
                                 b_mu0_C + get(muc_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name) +
                                       b_kappa_C +get(kappac_name)))'
             )
  mu_id_uh[i] = with(draws_all,
                      {
                        MedCDraws(b_mu0_Intercept + get(mu_name)  +
                                      b_mu0_C + get(muc_name))
                      })
  kappa_id_uh[i] = with(draws_all,
                         {softplus(median(Intercept_kappa+get(kappa_name)+
                                           b_kappa_C +get(kappac_name)))} )
  
  arrows.circular(x = circular(x = mu_id_uh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gh[i]),
                 lwd = 5,
                 length = 0.1/1.25,
                 col = adjustcolor('magenta3', alpha.f = 200/255))
  
  #green low
  with(subset(cd_all, 
              ID %in% u_id[i] &
                CL %in% 'g' & BR %in% 'l'),
  {
    PCfun(angles = bearing,
         col = 'green4',
         plot_rho = FALSE,
         title = u_id[i])
    }
  )
  Draws2Cont(draws_all,
             x_string = 'sin(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_B + get(mub_name))*
                         A1(softplus(Intercept_kappa +get(kappa_name)+
                                           b_kappa_B +get(kappab_name)))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_B + get(mub_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)+
                                           b_kappa_B +get(kappab_name)))'
             )
  mu_id_gl[i] = with(draws_all,
                      {
                        MedCDraws(b_mu0_Intercept + get(mu_name) +
                                        b_mu0_B + get(mub_name))
                      })
  kappa_id_gl[i] = with(draws_all,
                         {softplus(median(Intercept_kappa+get(kappa_name)+
                                            b_kappa_B + get(kappab_name)))} )
  
  arrows.circular(x = circular(x = mu_id_gl[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gh[i]),
                 lwd = 5,
                 length = 0.1/1.25,
                 col = adjustcolor('green4', alpha.f = 200/255))

  #UV low
  with(subset(cd_all, 
              ID %in% u_id[i] &
                CL %in% 'u' & BR %in% 'l'),
  {
    PCfun(angles = bearing,
         col = 'purple',
         plot_rho = FALSE,
         title = u_id[i])
    }
  )
  Draws2Cont(draws_all,
             x_string = 'sin(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_B + b_mu0_C + b_mu0_BC +
                                   get(mub_name) + get(muc_name) + get(mubc_name))*
                         A1(softplus(Intercept_kappa +get(kappa_name)+
                                   b_kappa_B + b_kappa_C + b_kappa_BC +
                                   get(kappab_name) + get(kappac_name) + get(kappabc_name)
             ))',
             y_string = 'cos(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_B + b_mu0_C + b_mu0_BC +
                                   get(mub_name) + get(muc_name) + get(mubc_name))*
                         A1(softplus(Intercept_kappa +get(kappa_name)+
                                   b_kappa_B + b_kappa_C + b_kappa_BC +
                                   get(kappab_name) + get(kappac_name) + get(kappabc_name)
             ))'
             )
  mu_id_ul[i] = with(draws_all,
                      {
                        MedCDraws(b_mu0_Intercept + get(mu_name) + 
                                   b_mu0_B + b_mu0_C + b_mu0_BC +
                                   get(mub_name) + get(muc_name) + get(mubc_name))
                      })
  kappa_id_ul[i] = with(draws_all,
                         {softplus(median(Intercept_kappa +get(kappa_name)+
                                   b_kappa_B + b_kappa_C + b_kappa_BC +
                                   get(kappab_name) + get(kappac_name) + get(kappabc_name)
                                   ))} )
  
  arrows.circular(x = circular(x = mu_id_ul[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gh[i]),
                 lwd = 5,
                 length = 0.1/1.25,
                 col = adjustcolor('purple', alpha.f = 200/255))
}

```


## Plot population level predictions


```{r Calculate estimates of means and changes}

#calculate mean vectors
mean_vectors = aggregate(angle~ID*brightn*colour+sun_az+sun_el_rad, # N.B. Including sun azimuth drops some cases without a time stamp
                         data = cd,
                         FUN = rho.circular
)
#correct names
mean_vectors = within(mean_vectors,
                      {mean_vector = angle; rm(angle)} # anlge now indicates a mean vector, not an angle
)
#add kappa
mle_estimates = aggregate(angle~ID*brightn*colour+sun_az+sun_el,
                          data = cd,
                          FUN = MLE_est
)
#Rayleigh tests
rayleigh_tests = aggregate(angle~ID*brightn*colour+sun_az+sun_el,
                          data = cd,
                          FUN = Rayleigh_p
                          )
#add to the summary table and 
#calculate inverse softplus kappa
mean_vectors = within(mean_vectors,
                      {
                        mu = deg(mle_estimates$angle[,'mu'])
                        kappa = mle_estimates$angle[,'kappa']
                        iskappa  = inv_softplus(kappa)
                      }
)

luc = sapply(u_id,
              FUN = IndCond,
              dt = cd)

#Most individuals that made it to bright green 
full_ids = u_id[luc == 4]

#find pair conditions
#green
grc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              colour %in% 'g'),
                     {
                       length(unique(brightn))
                       }
                     )
              },
              dt = cd)
#bright
brc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              brightn %in% 'h'),
                     {
                       length(unique(colour))
                       }
                     )
              },
              dt = cd)
#UV
uvc = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              colour %in% 'u'),
                     {
                       length(unique(brightn))
                       }
                     )
              },
              dt = cd)
#dim
dic = sapply(u_id,
              FUN = function(id, dt)
                {
                with(subset(dt,
                            ID %in% id & 
                              brightn %in% 'l'),
                     {
                       length(unique(colour))
                       }
                     )
              },
              dt = cd)

#There should be two brightness levels for green
gr_ids = u_id[grc == 2]
#There should be two colour levels for bright
br_ids = u_id[brc == 2]
#There should be two brightness levels for UV
uv_ids = u_id[uvc == 2]
#There should be two colour levels for dim
di_ids = u_id[dic == 2]

#condition specific
gh_ids = with(subset(cd_all,
                     subset = CL %in% 'g' & 
                       BR %in% 'h'),
              unique(ID)
              )
uh_ids = with(subset(cd_all,
                     subset = CL %in% 'u' & 
                       BR %in% 'h'),
              unique(ID)
              )
gl_ids = with(subset(cd_all,
                     subset = CL %in% 'g' & 
                       BR %in% 'l'),
              unique(ID)
              )
ul_ids = with(subset(cd_all,
                     subset = CL %in% 'u' & 
                       BR %in% 'l'),
              unique(ID)
              )


mu_diff_gl = sapply(X = gr_ids,
                    FUN = MuDiff,
                    dt = mean_vectors,
                    cl = 'g',
                    br = 'l')
mu_diff_uh = sapply(X = br_ids,
                    FUN = MuDiff,
                    dt = mean_vectors,
                    cl = 'u',
                    br = 'h')
mu_diff_ul = sapply(X = uv_ids,
                    FUN = MuDiff,
                    dt = mean_vectors,
                    cl = 'u',
                    br = 'l')
mu_diff_ugl = sapply(X = di_ids,
                    FUN = MuDiff,
                    dt = mean_vectors,
                     cl = 'u',
                    br = 'l',
                    ref_cl = 'g',
                    ref_br = 'h')

```

```{r Extract population level predictions}

par(pty = 's')
#Population mean for green bright
par(mfrow = c(1,4),
    mar = c(0,0,0,0))
with(subset(mean_vectors,
            colour %in% 'g' &
              brightn %in% 'h'),
     {
PCfun(angles = mu,
      col = 'green3',
      shrink = 2,
      plot_rho = FALSE)
     }
)

for(i in which(u_id %in% gh_ids) )
{

  arrows.circular(x = circular(x = mu_id_gh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gh[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('green3', alpha.f = 100/255))
}
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_Intercept)*
             A1(kappa_mu)',
           y_string = 'cos(b_mu0_Intercept)*
             A1(kappa_mu)'#,
           # palette = 'Mint'
           )

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_Intercept),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('green3', alpha.f = 200/255))
)

with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_Intercept), probs = c(0.5, 0.025, 0.975))
       ))
     }
)

with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_Intercept), probs = c(0.5, 0.025, 0.975))
       ))
     }
)
#pop mean for UV bright
with(subset(mean_vectors,
            colour %in% 'u' &
              brightn %in% 'h'),
     {
PCfun(angles = mu,
      col = 'magenta3',
      shrink = 2,
      plot_rho = FALSE)
     }
)

for(i in which(u_id %in% uh_ids) )
{

  arrows.circular(x = circular(x = mu_id_uh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_uh[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('magenta3', alpha.f = 100/255))
}
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_Intercept + b_mu0_C)*
             A1(kappa_muc)',
           y_string = 'cos(b_mu0_Intercept + b_mu0_C)*
             A1(kappa_muc)'#,
           # palette = 'Mint'
           )

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_Intercept + b_mu0_C),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_muc)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('magenta3', alpha.f = 200/255))
)


#pop mean for green dim
with(subset(mean_vectors,
            colour %in% 'g' &
              brightn %in% 'l'),
     {
PCfun(angles = mu,
      col = 'darkgreen',
      shrink = 2,
      plot_rho = FALSE)
     }
)

for(i in which(u_id %in% gl_ids) )
{

  arrows.circular(x = circular(x = mu_id_gl[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gl[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('darkgreen', alpha.f = 100/255))
}
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_Intercept + b_mu0_B)*
             A1(kappa_mub)',
           y_string = 'cos(b_mu0_Intercept + b_mu0_B)*
             A1(kappa_mub)'#,
           # palette = 'Mint'
           )

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_Intercept + b_mu0_B),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mub)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('darkgreen', alpha.f = 200/255))
)

#pop mean for UV dim
with(subset(mean_vectors,
            colour %in% 'u' &
              brightn %in% 'l'),
     {
PCfun(angles = mu,
      col = 'purple',
      shrink = 2,
      plot_rho = FALSE)
     }
)

for(i in which(u_id %in% ul_ids) )
{

  arrows.circular(x = circular(x = mu_id_ul[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_ul[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('purple', alpha.f = 100/255))
}
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_Intercept + b_mu0_B + b_mu0_C + b_mu0_BC)*
             A1(kappa_mubc)',
           y_string = 'cos(b_mu0_Intercept + b_mu0_B + b_mu0_C + b_mu0_BC)*
             A1(kappa_mubc)'#,
           # palette = 'Mint'
           )

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_Intercept + b_mu0_B + b_mu0_C + b_mu0_BC),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mubc)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('purple', alpha.f = 200/255))
)


  


#effect of UV
PCfun(angles = unlist(mu_diff_uh),
      col = 'gray40',
      shrink = 2,
      plot_rho = FALSE)

for(i in which(u_id %in% uv_ids) )
{
   #UV high
  
  arrows.circular(x = circular(x = mu_id_uh[i] - mu_id_gh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_uh[i]),
                 lwd = 0.5,
                 length = 0,
                 col = adjustcolor('magenta3', alpha.f = 100/255))
  
}

Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_C)*
             A1(kappa_muc)',
           y_string = 'cos(b_mu0_C)*
             A1(kappa_muc)'#,
           # palette = 'Purp'
           )

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_C),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('gray40', alpha.f = 200/255))
)


with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_C), probs = c(0.5, 0.025, 0.975))
       ))
     }
)

#effect of dim green
PCfun(angles = unlist(mu_diff_gl),
      col = 'darkgreen',
      shrink = 2,
      plot_rho = FALSE)

#green low
for(i in which(u_id %in% gr_ids))
{
  arrows.circular(x = circular(x = mu_id_gl[i] - mu_id_gh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_gl[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('green4', alpha.f = 100/255))
}

Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_B)*
             A1(kappa_mub)',
           y_string = 'cos(b_mu0_B)*
             A1(kappa_mub)'#,
           # palette = 'YlGn'
           )

with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_B), probs = c(0.5, 0.025, 0.975))
       ))
     }
)

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_B),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mu)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('darkgreen', alpha.f = 200/255))
)

#effect of dim UV
PCfun(angles = unlist(mu_diff_ul),
      col = 'purple',
      shrink = 2,
      plot_rho = FALSE)

#UV low
for(i in which(u_id %in% uv_ids))
{
  arrows.circular(x = circular(x = mu_id_ul[i] - mu_id_uh[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_ul[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('purple', alpha.f = 100/255))
}
#the difference between UV bright and UV dim is brightness and the interaction
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_B + b_mu0_BC)*
             A1(kappa_mubc)',
           y_string = 'cos(b_mu0_B + b_mu0_BC)*
             A1(kappa_mubc)'#,
           # palette = 'YlGn'
           )

with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_B + b_mu0_BC), probs = c(0.5, 0.025, 0.975))
       ))
     }
)

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_B + b_mu0_BC),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mubc)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('purple', alpha.f = 200/255))
)

#effect of dim UV relative to dim green
PCfun(angles = unlist(mu_diff_ugl),
      col = 'gray25',
      shrink = 2,
      plot_rho = FALSE)

#UV low
for(i in which(u_id %in% di_ids))
{
  arrows.circular(x = circular(x = mu_id_ul[i] - mu_id_gl[i],
                               units = 'radians',
                              rotation = 'clock',
                              zero = pi/2),
                 y = A1(kappa_id_ul[i]),
                 lwd = 0.25,
                 length = 0,
                 col = adjustcolor('gray25', alpha.f = 100/255))
}
#the difference between green dim and UV dim is colour and the interaction
Draws2Cont(draws = draws_all,
           x_string = 'sin(b_mu0_C + b_mu0_BC)*
             A1(kappa_mubc)',
           y_string = 'cos(b_mu0_C + b_mu0_BC)*
             A1(kappa_mubc)'#,
           # palette = 'YlGn'
           )

with(draws_all,
     {
       round(deg(
     quantile(mod_circular(b_mu0_C + b_mu0_BC), probs = c(0.5, 0.025, 0.975))
       ))
     }
)

with(draws_all,
     arrows.circular(x = circular(x = MedCDraws(b_mu0_C + b_mu0_BC),
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2),
     y = A1(median(kappa_mubc)),
     lwd = 5,
     length = 0.1/1.25,
     col = adjustcolor('gray25', alpha.f = 200/255))
)
```

```{r Kappa effects}
#plot kappa
par(mfrow = c(1,3))

with(draws_all,
     VertHist(data = softplus(Intercept_kappa), 
              main = '\ngreen bright',
              ylab = 'kappa',
              ylim = c(0, 15),
              col = adjustcolor('green3', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)

with(draws_all,
     VertHist(data = softplus(Intercept_kappa + b_kappa_C), 
              main = '\nUV bright',
              ylab = 'kappa',
              ylim = c(0, 15),
              col = adjustcolor('magenta3', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)

with(draws_all,
     {
       round(
     quantile(softplus(Intercept_kappa + b_kappa_C) - 
                softplus(Intercept_kappa),
              probs = c(0.5, 0.025, 0.975)),
     digits = 2
       )
     }
)

with(draws_all,
     VertHist(data = softplus(Intercept_kappa + b_kappa_B), 
              main = '\ngreen dim',
              ylab = 'kappa',
              ylim = c(0, 15),
              col = adjustcolor('green4', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)


with(draws_all,
     {
       round(
     quantile(softplus(Intercept_kappa + b_kappa_B) - 
                softplus(Intercept_kappa),
              probs = c(0.5, 0.025, 0.975)),
     digits = 2
       )
     }
)

```

```{r Kappamu effects}
#plot kappa
par(mfrow = c(1,3))

with(draws_all,
     VertHist(data = kappa_mu, 
              main = '\ngreen bright',
              ylab = 'kappamu',
              ylim = c(0, 15),
              col = adjustcolor('green3', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)

with(draws_all,
     VertHist(data = kappa_muc, 
              main = '\nUV effect',
              ylab = 'kappamu',
              ylim = c(0, 15),
              col = adjustcolor('gray50', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)

with(draws_all,
     VertHist(data = kappa_mub, 
              main = '\ndim effect',
              ylab = 'kappamu',
              ylim = c(0, 15),
              col = adjustcolor('darkgreen', alpha.f = 100/255),
              axes = FALSE,
              cex.axis = 0.7))
axis(1)
axis(2, at = 0:5*5)


```

# Model comparison for unimodal
## Set up formula and priors


```{r Unimodal change formula}

formula_noCL = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui + muib), #primary mean, population mean plus individual mean
  mu0 ~ 1 + BR , #population level effects
  mui ~ 0 + ID, # individual mu offset 
  muib ~ 0 + B:ID, # individual mu offset for brightness
  kappa ~ 1 + BR + (1 + BR | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

formula_noBR = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui +muic), #primary mean, population mean plus individual mean
  mu0 ~ 1 + CL , #population level effects
  mui ~ 0 + ID, # individual mu offset 
  muic ~ 0 + C:ID, # individual mu offset for uv
  kappa ~ 1 + CL + (1 + CL | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

formula_KnoCL = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui + muib), #primary mean, population mean plus individual mean
  mu0 ~ 1 + BR , #population level effects
  mui ~ 0 + ID, # individual mu offset 
  muib ~ 0 + B:ID, # individual mu offset for brightness
  kappa ~ 1 + BR + CL + (1 + BR | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

formula_KnoBR = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui + muic), #primary mean, population mean plus individual mean
  mu0 ~ 1 + CL , #population level effects
  mui ~ 0 + ID, # individual mu offset 
  muic ~ 0 + C:ID, # individual mu offset for uv
  kappa ~ 1 + BR + CL + (1 + CL | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

formula_null = bf(#modulus may not be necessary, included in lpd function
  formula = angle ~ mu,
  nlf(mu ~ mu0 + mui), #primary mean, population mean plus individual mean
  mu0 ~ 1 , #population level effects
  mui ~ 0 + ID, # individual mu offset 
  kappa ~ 1 + (1 | ID), #concentration for primary mean
  family = unwrap_von_mises,
  nl = TRUE)#to accept user-defined extra parameters (mui) we need to treat the formula as nonlinear

```

N.B. Since the priors specify changes, but not what kind, each change model can use the same priors.
 
```{r Null change priors}

#priors for mu
pr_mu_null = prior('normal(0, pi()/1)', coef = 'Intercept', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                      check = FALSE)  #

#priors for kappa
pr_kappa_null = 
                  prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') +
                  prior('student_t(3, 0, 2.0)', class = 'sd', dpar = 'kappa')



#priors for mu
pr_mu_nobr = prior('normal(0, pi()/1)', coef = 'Intercept', nlpar = 'mu0') +
                  prior('normal(0, pi()/2)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                      check = FALSE)  +
  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu + softkappamuc))',
                        nlpar  = 'muic',  class = 'b') +
            set_prior("target += normal_lpdf(softkappamuc | 0, 1.0)", #expect small differences 
                      check = FALSE)  


#priors for mu
pr_mu_nocl = prior('normal(0, pi()/1)', coef = 'Intercept', nlpar = 'mu0') +
                  prior('normal(0, pi()/2)', class = 'b', nlpar = 'mu0') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu))',
                        nlpar  = 'mui',  class = 'b') +
            set_prior("target += lognormal_lpdf(log1p_exp(softkappamu) | log(30), 0.6)", #expect high concentration (low variation) 
                      check = FALSE)  +
  prior('unwrap_von_mises_vect(0, log1p_exp(softkappamu + softkappamub))',
                        nlpar  = 'muib',  class = 'b') +
            set_prior("target += normal_lpdf(softkappamub | 0, 1.0)", #expect small differences 
                      check = FALSE)  


  
#no mu colour priors
pr_nobr = pr_mu_nobr + pr_kappa_all

#no mu brightness priors
pr_nocl = pr_mu_nocl + pr_kappa_all

  
#all bimodal priors
pr_null = pr_mu_null + pr_kappa_null
```

## Run the alternative models

```{r run alternative models}

#very long compile time
system.time(
  {
    
    model_noCL = brm(formula = formula_noCL,
                     # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = cd_all,
                   prior = pr_nocl,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu +
                     stan_softkappamub,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), #Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/noCL_model.RData',
     model_noCL)#save for future reference

system.time(
  {
    
    model_noBR = brm(formula = formula_noBR,
                     # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = subset(cd_all),
                   prior = pr_nobr,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu+
                     stan_softkappamuc,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), #Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/noBR_model.RData',
     model_noBR)#save for future reference

system.time(
  {
    
    model_null = brm(formula = formula_null,
                     # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = subset(cd_all),
                   prior = pr_null,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), #Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/uninull_model.RData',
     model_null)#save for future reference

```

```{r Kappa only models}

#very long compile time
system.time(
  {
    
    model_KnoCL = brm(formula = formula_KnoCL,
                     # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = subset(cd_all),
                   prior = pr_nocl,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu+
                     stan_softkappamub,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), #Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/KnoCL_model.RData',
     model_KnoCL)#save for future reference

system.time(
  {
    
    model_KnoBR = brm(formula = formula_KnoBR,
                     # data = subset(cd_all, ID %in% u_id[1:20]),
                   data = subset(cd_all),
                   prior = pr_nobr,
                   stanvars = stan_unwrap_fun + 
                      modulo_circular_fun + 
                      stan_softkappamu+
                     stan_softkappamuc,
                   chains = 4, # 4 chains in parallel
                   cores = 4, # on 4 CPUs
                   warmup = 1000, #
                   iter = 3000, # longer sampling to efficiently sample mu0
                   refresh = 500,
                   control = list(adapt_delta = 0.90),
                   silent = 1, # echo only high priority Stan messages
                   save_pars = save_pars(all = TRUE), #Crucial for moment matching
                   backend = 'cmdstanr')
    
  }
)
save(file = '2Results/KnoBR_model.RData',
     model_KnoBR)#save for future reference

```

## Unimodal LOO comparison
```{r Loo comparison for unimodal models}
#collect models
load(file = '2Results/uni_model.RData')#model_all
load(file = '2Results/noCL_model.RData')#model_noCL
load(file = '2Results/noBR_model.RData')#model_noBR
load(file = '2Results/KnoCL_model.RData')#model_KnoCL
load(file = '2Results/KnoBR_model.RData')#model_KnoBR
load(file = '2Results/uninull_model.RData')#model_null

modlist = list(maximal = model_all,
               KnoCL = model_noCL,
               KnoBR = model_noBR,
               noCL = model_noCL,
               noBR = model_noBR,
               null = model_null
                )

#calculate loo
modlist = lapply(modlist,
       FUN = add_criterion,
       'loo',
       moment_match = TRUE)

save(modlist,
     file = '2Results/uni_modlist.RData')

#compare all models
lc_all = with(modlist, loo_compare(maximal, KnoCL, KnoBR, noCL, noBR, null))
print(lc_all)
#effect of UV bright
with(modlist, loo_compare(maximal, KnoCL))
#effect of green dim
with(modlist, loo_compare(maximal, KnoBR))
#compare LOO IC
LooIC = function(lmod)
{
  loo(lmod)$estimates['looic', 'Estimate']
}

modLIC = lapply(X = modlist,
       FUN = LooIC)
print(sort(unlist(modLIC)), digits = 1)

```

```{r Plot the model comparison}

lc_plot = with(modlist,
  data.frame(elpd = c(null$criteria$loo$estimates['elpd_loo','Estimate'],
                      noBR$criteria$loo$estimates['elpd_loo','Estimate'],
                      KnoBR$criteria$loo$estimates['elpd_loo','Estimate'],
                      noCL$criteria$loo$estimates['elpd_loo','Estimate'],
                      KnoCL$criteria$loo$estimates['elpd_loo','Estimate'],
                      maximal$criteria$loo$estimates['elpd_loo','Estimate'],
                      maximal$criteria$loo$estimates['elpd_loo','Estimate'] -
                                  lc_all['KnoCL','elpd_diff']),
                     se = c(null$criteria$loo$estimates['elpd_loo','SE'],
                            noBR$criteria$loo$estimates['elpd_loo','SE'],
                            KnoBR$criteria$loo$estimates['elpd_loo','SE'],
                            noCL$criteria$loo$estimates['elpd_loo','SE'],
                            KnoCL$criteria$loo$estimates['elpd_loo','SE'],
                            maximal$criteria$loo$estimates['elpd_loo','SE'],
                            lc_all['noCL','se_diff'])
                     )
)

par(mar = c(0,4,0,4),
    mfrow = c(1,1))
plot(x = 1:dim(lc_plot)[1],
     y = lc_plot$elpd,
     xlab = '',
     ylab = 'expected log predictive density',
     xlim = c(1,dim(lc_plot)[1]) + c(-1,1)*0.5,
     ylim = with(lc_plot, {range(elpd+se%*% t(c(-2,2)))}), #within 2sigma of all estimates
     pch = 19,
     col = c(col_obs, col_kappa, col_kappa, col_treat, col_treat, col_sd2, col_rho),
     cex = 2,
     axes = FALSE)
with(lc_plot,
     {
arrows(x0 = 1:dim(lc_plot)[1],
       x1 = 1:dim(lc_plot)[1],
       y0 = elpd - se,
       y1 = elpd + se,
       code = 3,
       angle = 90,
       length = 0.1,
       lwd = 3,
       col =  c(col_obs, col_kappa, col_kappa, col_treat, col_treat, col_sd2, col_rho)
       )
     }
)
axis(2,
     at = pretty(
                   with(lc_plot, {range(elpd+se%*% t(c(-2,2)))})
                 )
     )
axis(4,
     at = with(lc_plot,
               {
               seq(from = elpd[5], to = elpd[dim(lc_plot)[1]] + se[dim(lc_plot)[1]]*4, by = 20)
               }
               ),
     labels = with(lc_plot,
                          {
                            seq(from = 0, to =  elpd[dim(lc_plot)[1]] + se[dim(lc_plot)[1]]*4 - elpd[5],  by = 20)
                          }
     ),
     col = col_rho
)
abline(h = lc_plot$elpd[5],
       col = 'gray')
mtext(text = 'ELPD difference',
      side = 4,
      line = 3
      )
mtext(side = 1,
      line = -1,
      at = 1:dim(lc_plot)[1],
     text = c('null\nmodel',
              'no\nbrightness',
              'kappa\nbrightness',
              'no\ncolour',
              'kappa\ncolour',
              'colour &\nbrightness',
              'difference'),
     col = c(col_obs, col_kappa, col_kappa, col_treat, col_treat, col_sd2, col_rho)
     )


```